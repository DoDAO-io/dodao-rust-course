- title: Understanding ownership
  shortTitle: ownership
  key: ownership
  details: |
    - In Rust, ownership is the most unique feature and allows memory safety to be guaranteed without the use of garbage collectors.
    - Ownership is Rust's defining characteristic. A computer's memory must be managed by all programs while they run.
    - A computer's memory must be managed by all programs while they run.
    - A third approach is used by Rust: memory ownership is governed by a set of rules that the compiler checks during compile.A third approach is used by Rust: memory ownership is governed by a set of rules that the compiler checks during compile.
    - None of the ownership features slow down your program while it’s running.
    - A Rust program's ownership rules are checked at compile time by the Rust compiler. These rules must be followed for the program to run. These rules must be followed for the program to run.
    - The borrow checker is used by Rust to verify ownership rules. In Rust, ownership rules are verified using the borrow checker. By checking the ownership model, the borrow checker determines whether a value in memory (stack or heap) is within scope.
    - Out-of-scope values cannot be accessed by other parts of the program unless they are borrowed.
    - Understanding ownership will give you a solid understanding of Rust's features.Understanding ownership will give you a solid understanding of Rust's features.
    - The Ownership Rules
    - It is the responsibility of every variable to own the value it was initialized with, and a variable can only have one owner.
    - As soon as the owner is removed from scope, the value is lost.
    - Understanding the rules of ownership is important.
    - Let's examine the ownership rules. While we look at the examples that illustrate these rules, keep them in mind:
    - Every variable owns its initial value, so that is the first ownership rule.
       ```rust
           let owner = String::from("one");
       ```
    - In contrast to Python and Go, when the owner variable is reassigned, the string value will be dropped.
    - Second rule, no two variables can point to the same memory location; each value has only one owner.
      ```rust
          let new_owner = owner;
      ```
    -  At the memory location where the owner variable was stored, the new_owner variable now owns it.
    -  Using the owner variable will cause the compiler to panic, preventing the executable from being generated.
    -  The three ownership rule states that a variable gets dropped once it leaves its declared scope, and its memory is deallocated.
      ```rust
         // a variable in a separate scope
         {
         let example = String::from("Here's a new scope");
           }
             print!("{}", example)
     ```
    - This example variable cannot be accessed outside its scope; attempting to do so will cause the compiler to panic.
    - Ownership in Functions
      - Even though a variable wasn't declared in the function's scope, it can be accessed as an argument:
    ```rust
        fn printer(value: String)  > String {
                     return value
           }

         fn main() {
           let x = String::from("Prints a value"); // x owns the string value

           // ownership is moved to the printer function here
            print!("{} The Result of Printing X is that it  :", printer(x));
        }
    ```
    Rust moves ownership of that variable to the function at compile time, so the function can access it.
    Return Values and Scope
    Returning values can also transfer ownership. 
    ```rust
      fn main() {
         let s1 = gives_ownership(); // gives_ownership moves its return
          // value into s1
         let s2 = String::from("hello"); // s2 comes into scope
         let s3 = takes_and_gives_back(s2); // s2 is moved into
         // takes_and_gives_back, which also
         // moves its return value into s3
            } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
        // moved, so nothing happens. s1 goes out of scope and is dropped.
      fn gives_ownership()  > String { // gives_ownership will move its
        // return value into the function
        // that calls it
          let some_string = String::from("hello"); // some_string comes into scope
          some_string // some_string is returned and
            // moves out to the calling
            // function
          }
        // takes_and_gives_back will take a String and return one
      fn takes_and_gives_back(a_string: String)  > String { // a_string comes into
      // scope
        a_string // a_string is returned and moves out to the calling function
        }
      ```
    - Assignment of a value to another variable always moves the ownership of a variable. 
    - Variables that contain heap data will be dropped when they go out of scope, unless the data has been moved to another variable. With each function, you need to take ownership and return ownership. 
    - Is it possible to let a function use a value, but not take ownership of it? As well as any data resulting from the body of the function that we might want to return, anything we pass in also needs to be passed back in order to use it again.

    - Returning ownership of parameters

      ```rust
        fn main() {
          let s1 = String::from("hello");
          let (s2, len) = calculate_length(s1);
          println!("The length of '{}' is {}.", s2, len);
        }
         fn calculate_length(s: String)  > (String, usize) {
          let length = s.len(); // len() returns the length of a String
          (s, length)
          }
      ```
    - This is too much ceremony and work for a concept that should be commonplace. This concept is fortunately supported by Rust's references feature. Which we will touch soon.
    - Rust Prioritizes Code Reusability
    - The practice of code reusability is an essential skill, but you must understand Rust's ownership rules to be able to practice it.
    - Rust is one of the most flexible programming languages available. In order to make variables reusable, it provides concepts such as borrowing, moving, copying, and cloning ownership.

- title: Reference and Borrowing
  shortTitle: Borrowing
  key: borrowing
  details: |
    - In our previous section, we had to return the String to the calling function so that we could use it after we called calculate_length, because the String had been moved into it.
    - Instead of taking ownership of the value, here is how you would define and use a calculate_length function that takes a reference to an object as a parameter:

       ```rust
        fn main() {
         let s1 = String::from("hello");
         let len = calculate_length(&s1);
         println!("The length of '{}' is {}.", s1, len);
        }
        fn calculate_length(s: &String)  > usize {
        s.len()
      }
       ```
    - Note that all tuple codes in the variable declaration and function return value have been removed. Secondly, we pass &s1 to calculate_length and use &String instead of String in its definition. By using these ampersands, you can refer to some value without owning it.
    - Referencing is accomplished by using &, while dereference is accomplished with *. - 
    - Let’s take a closer look at the function call here:
      ```rust
        let s1 = String::from("hello");
        let len = calculate_length(&s1);
      ```
    - By using the &s1 syntax, we can create a reference to s1 that does not own it. When the reference goes out of scope, the value it points to won't be dropped because it doesn't own it. As well, the function signature uses & to indicate that the parameter s is a reference. When the variable s goes out of scope, we don't drop what the reference points to since we don't have ownership over it. We don't need to return ownership when functions have references as parameters instead of the actual values, since we never owned them.    - 
    - Borrowing is what we call having references as function parameters.
    - If a person owns something, it can be borrowed just like in real life. When finished, it must be returned. Lets try to modify something we are borrowing below
      ```rust
          fn main() {
              let s = String::from("hello");
              change(&s);
          }
          fn change(some_string: &String) {
              some_string.push_str(", world");
          }
      ```
    -  Here’s the error:
       ```rust
        error[E0596]: cannot borrow immutable borrowed content `*some_string` as
        mutable
          > error.rs:8:5
         |
       7 | fn change(some_string: &String) {
         |         use `&mut String` here to make mutable
       8 | some_string.push_str(", world");
         | ^^^^^^^^^^^ cannot borrow as Mutable
      ```
    - Variables and references are immutable by default, so it is impossible to change what you are referencing.

    - Mutable reference
    - we can fix the issue above via mutable reference
      ```rust
        fn main() {
          let mut s = String::from("hello");
          change(&mut s);
        }
        fn change(some_string: &mut String) {
          some_string.push_str(", world");
        }
      ```

    - First, I had to bravely change. Then I had to create a mutable reference with &mut and accept a mutable reference with some_string .
    - &mut string.
    - However, mutable references have one major limitation.
    - You can have only one mutable reference to a given data item within a given scope.
    - This code will fail:
      ```rust
        let mut s = String::from("hello");
        let r1 = &mut s;
        let r2 = &mut s;
        println!("{}, {}", r1, r2);
      ```
    - Here’s the error:
       ```rust
         error[E0499]: cannot borrow `s` as mutable more than once at a time
             > src/main.rs:5:14
            |
          4 |  let r1 = &mut s;
            |                 first mutable borrow occurs here
          5 |  let r2 = &mut s;
            |          ^^^^^^ second mutable borrow occurs here
          6 |
          7 |    println!("{}, {}", r1, r2);
            |                 first borrow later used here
       ```
    - This restriction allows modification, but in a very controlled manner. And new Rustaceans will struggle with it. As most languages ​​allow mutation at any time. The advantage of this limit is that Rust can prevent compile-time data races. A data race is similar to a race condition and happens when these three behaviors occur:
     • Two or more pointers access similar data simultaneously.
     • At least one of the pointers is being used to write to the data.
     • There's no mechanism being used to synchronize access to the data.
    - Data races cause undefined behavior and can be difficult to troubleshoot or fix when you're trying to find them down at runtime.
    - Rust has an advantage here because once it spots a code with data races it wouldn’t compile it.
    - We use curly brackets to create a new scope, allowing for multiple mutable references, just not simultaneous ones:

      ```rust
       let mut s = String::from("hello");
        {
          let r1 = &mut s;
          } // r1 goes out of scope here, so we can make a new reference with no
        // problems.
          let r2 = &mut s;
      ```
        A similar rule exists for combining mutable and immutable references.
        This code results in an error:
      ```rust 
         let mut s = String::from("hello");
         let r1 = &s; // no problem
         let r2 = &s; // no problem
         let r3 = &mut s; // BIG PROBLEM
            println!("{}, {}, and {}", r1, r2, r3);
      ```
        And this will lead to an Error
      ```rust
        error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
          immutable
          > 6:14
         |
       4 | let r1 = &s; // no problem
         |    immutable borrow occurs here
       5 | let r2 = &s; // no problem
       6 | let r3 = &mut s; // BIG PROBLEM
         |        ^^^^^^ mutable borrow occurs here
       7 |
       8 | println!("{}, {}, and {}", r1, r2, r3);
         |                     immutable borrow later used here  
    ```

    - We also cannot have a mutable reference while we have an immutable reference.
    - Users of immutable references don't expect values ​​to suddenly change with them! However, multiple immutable references are acceptable because no one is just reading the data potentially affecting someone else reading the data.

    -  Dangling References

    - In pointer languages, it is easy to mistakenly create a hanging pointer, a pointer that refers to a location in memory that may have been allocated to someone else, freeing the memory while preserving the pointer to it. this memory. In Rust, on the other hand, the compiler guarantees that no references are made.

    - Let’s try to create a dangling reference, which Rust will prevent with a compile time error:
    ```rust
      fn main() {
        let reference_to_nothing = dangle();
        }
        fn dangle()  > &String {
          let s = String::from("hello");
          &s
        }
    ```
      The error we get is
    ```rust
      error[E0106]: missing lifetime specifier
          > main.rs:5:16
         |
       5 | fn dangle()  > &String {
         |                ^expected lifetime parameter
         |
         = help: this function's return type contains a borrowed value, but there is
          no value for it to be borrowed from
         = help: consider giving it a 'static lifetime
    ```
    - This error message refers to a feature we haven’t covered yet: lifetimes
    - The Rules of References
    - Let’s recap what we’ve discussed about references
      • At any time, you can have either, but not both, of the following:
        - mutable references or any number of immutable references.
      • References should always be valid. 
    -  Let's look at a kind of reference: slices.
     
    - The Slice Type

    - Another data type that has no attributes is Slice. Slices allow you to refer to a sequence of contiguous items in a collection rather than the entire collection.
    - Here's a little programming problem:
    - write a function that takes a string and returns the first word it finds in that string. If the function does not find a space in the string, then the entire string must consist of a single word, so the entire string must be returned.
    - Let’s think about the signature of this function:
     ```rust
       fn first_word(s: &String)  > ?
     ```
    - The function has a &string as a parameter, no ownership of it. which is fine. But what shouls we return?
    - We don’t really have a way to talk about part of a string. However, we could return the index of the end of the word.
    - Let’s try that
      ```rust
         fn first_word(s: &String)  > usize {
             let bytes = s.as_bytes();
             for (i, &item)v in bytes.iter()w.enumerate() {
                   if item == b' ' {
                        return i;
                }
               s.len()
               }
      ```
    - The first_word function returns the byte index value in the String parameter which we don't have to explain in depth.
    - As this may be beyond the scope of this chapter.
    - String Slice
    - A string slice is a reference to part of a String, and it looks like this:
      ```rust  
        let s = String::from("hello world");
        let hello = &s[0..5];
        let world = &s[6..11];
      ```
    - This is equivalent to getting a reference to the entire string but with the extra bit [0..5]. Instead of a reference to the entire string, this is a reference to a portion of the string. We can create slices using a range in parentheses by specifying [starting index..ending_index], where start_index is the first position in the slice and end_index is one more position than the other. the last position in a moment
    - String Literals Are Slices
    - Recall that we talked about string literals being stored inside the binary. Now that we know about slices, we can properly understand string literals:
          ```rust
             let s = "Hello, world!";
          ```
    - The type of s here is &str:
    - it is a slice pointing to that particular point in the binary. This is also why string characters are immutable; & str is an immutable reference.
    - String Slices as Parameters
    - Knowing that you can take slices of literals and String values leads us to one more improvement on first_word, and that’s its signature:
          ```rust
            fn first_word(s: &String)  > &str {
          ```
    -  A more experienced Rustacean would write the signature shown in below instead because it allows us to use the same function on both
    -  String and &str values.
        ```rust
          fn first_word(s: &str)  > &str {
        ```

    - The concepts of ownership, borrowing, and slicing ensure compile-time memory security for Rust programs.
    - The Rust language allows you to control memory usage just like any other system programming language.
    - However, if the owner of the data automatically sanitizes that data
    - Having the owner out of scope means that you don't have to write and debug additional code to gain control of it.

- title: Memory Allocation
  shortTitle: Memory Allocation
  key: memory allocation
  details: |
    - Program elements are functions, modules, and types whose values ​​are computed at compile time and stored uniquely in the Rust process' memory dump.
    - Items are not dynamically allocated or deallocated.
    - A heap is a generic term for a box. The lifetime of an allocation in the heap depends on the lifetime of the boxed value that references it.
    - Box values ​​themselves may move in and out of frames, or be stored on the heap, so heap allocations can live in the frame in which they were allocated.
    - Allocations within the heap are guaranteed to reside in one location within the heap for the lifetime of the allocation.
    - It doesn't shift when the box value shifts.
    - Each Rust program process is allocated virtual memory by the operating system "OS". This is the total memory accessible to the process.
       ![process virtual memory](https://i.imgur.com/mUOasWj.png)
    - This is very simple compared to the JVM, V8 and Go memory structures we saw in the previous chapter.
    - As you can see, there is no garbage collection (GC) involved, so there is no generational memory or complex substructures. Various storage in the great
    - heap
    - This is where all dynamic data (all data whose size cannot be calculated at compile time) is stored.
    - This is the largest block of memory and the part managed by Rust's ownership model.
    - Box: Boxed types are Rust's abstraction for heap-allocated values.
    - Heap memory is allocated when Box::new is called. A Box<T>contains a smart pointer to heap memory allocated for type T , and the reference is saved on the stack.
    - Stack
    - This is the stack memory area, with one stack per thread.
    - By default a static value is assigned here.
    - Static data (data size known at compile time) includes function frames, primitives, structures, and pointers to dynamic data in the heap. For string literals, the contents are known at compile time.
    - The text is hardcoded directly into the final executable. Because of this, string literals are fast and efficient.
    - But these properties come only from the immutability of string literals.
    - Unfortunately, chunks of memory cannot be inserted into the binary for every piece of text whose size is unknown at compile time and whose size may change during program execution.
    - The String type needs to allocate an unknown amount of memory on the heap to support mutable and extensible text
    - Compile time to preserve content. this means:

      • Memory must be claimed by the operating system at runtime.
      • There must be a way to return this memory to the operating system.
    - The string is now complete.
    - The first part of this is done by us:
    - Calling a String looks like this:: Request the required memory for that implementation.
    - This is pretty universal in programming languages.
    - The second part is different, however. When you are using a language with a garbage collector (GC), you don't have to worry about it because the GC tracks and cleans up memory when you are not using it.
    - Without GC, it's our responsibility to detect when memory is unused and call our code
    - Please return expressly as we requested.
    - Getting this right has been a difficult programming problem in the past. Forgetting is a waste of memory.
    - Do it too early and you'll end up with invalid variables. If you do it twice, it's also wrong. Exactly one allocation must be merged into exactly one free allocation.
    - Rust takes a different approach:
    - When the variable that owns the storage goes out of scope, the storage is automatically returned.
    - variable range
    - We have already seen an example Rust program in the previous section.
    - I'm done with the basic syntax, so I won't include all the 'fn main() {' code in the example.
    - So if you want to follow, you should include
    - Example manually in the main function.
    - As a result, the samples are a bit more concise, allowing us to focus on the details rather than the standard code.
