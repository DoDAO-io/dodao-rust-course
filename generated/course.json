{
  "key": "rust-course",
  "title": "Rust Course",
  "summary": "Smart contracts allow users to implement conditions, rules and policies of the blockchain applications. \nIn this course you will learn how to write smart contracts and all the features of Rust language.\n",
  "details": "\"Line1\" \n\"Line2\" \n\"Line3\"\n",
  "duration": "4 - 6 hours",
  "highlights": [
    "Rust smart contracts",
    "All the features of Rust",
    "Advanced Rust concepts",
    "Summaries and questions for each chapter"
  ],
  "publishStatus": "Live",
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/Rust/rust-logo-512x512.png",
  "topics": [
    {
      "title": "Your First Solana Smart Contract",
      "key": "first-smart-contract",
      "details": "This chapter introduces you to the world of solana smart contracts written in rust. Covered topics in this chapter\n - Introduction to a simple smart contract\n - Explanation of the whole smart contract\n - Project Management with Cargo Crates\n    1. Installing Cargo\n    2. Packages and Crates\n    3. toml and Project formats\n    4. Cargo Commands\n",
      "order": 0,
      "questions": [
        {
          "uuid": "ab88a2ab-c80b-49f5-9ea0-b5ed8e4933b1",
          "type": "SingleChoice",
          "content": "What is the output of the following code snippet:\n \n    ``` \n        fn main() {\n          let x = 12;\n          println!(\"The value of x is: {x}\");\n          x = 8;\n          println!(\"The value of x is: {x}\");\n        } \n    ```\n",
          "hint": "NoHint",
          "explanation": "Error would occur, because the variable x isn't set as mutable so it's value can't be changed.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The value of x is: 8",
              "key": "A"
            },
            {
              "content": "Error: the variable x is mutable",
              "key": "B"
            },
            {
              "content": "The value of x is: 12",
              "key": "C"
            },
            {
              "content": "Error: the variable x is immutable",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "23a0e9e5-6c47-4512-98a5-4cd3ab6eff25",
          "type": "SingleChoice",
          "content": "Space taken by a Character data type in rust is",
          "hint": "It doesn't use ASCII values",
          "explanation": "Rust's char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1 byte",
              "key": "A"
            },
            {
              "content": "4 bytes",
              "key": "B"
            },
            {
              "content": "8 bytes",
              "key": "C"
            },
            {
              "content": "16 bytes",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "39385b22-7604-492f-9c2e-aaae409c6b79",
          "type": "SingleChoice",
          "content": "Rust is a Dynamically typed language.",
          "hint": "Does the compiler need to know the data type at compile time?",
          "explanation": "It is statically typed",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "6b844c24-f769-4662-a591-83c0a5f8c6c3",
          "type": "SingleChoice",
          "content": "Select the incorrect declaration statement",
          "hint": "NoHint",
          "explanation": "It is declared as an unsigned integer, but the value is negative",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let mut x: u32 = 20;",
              "key": "A"
            },
            {
              "content": "let mut x: i32 = -20;",
              "key": "B"
            },
            {
              "content": "let mut x: u32 = -20;",
              "key": "C"
            },
            {
              "content": "let mut x = 20;",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6f2cb4ae-db4d-4c04-bfd4-37669695dab0",
          "type": "SingleChoice",
          "content": "Suppose you declared a variable as u8 and then assigned it a value of \"257\". What would be the output if it’s compiled with a \"`“--release” flag?`\"",
          "hint": "NoHint",
          "explanation": "After 255 the digits start rolling back to 0, 1 and so on",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "257",
              "key": "A"
            },
            {
              "content": "Error: Integer Overflow",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0708f185-46b5-45ee-ac47-3e7e1ca611b3",
          "type": "SingleChoice",
          "content": "Are Tuples in rust dynamic in nature?\n\"Eg:-\" \n``` \n  let tup: (i32, f64, bool) = (500, 6.4, true); \n```\n",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Yes",
              "key": "A"
            },
            {
              "content": "No",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d11a531f-f32f-4764-a60a-2cc5af348245",
          "type": "SingleChoice",
          "content": "Select the correct statements for the two String     types(“String” and “&str”).\n \"a. “Strings” are immutable in nature and cannot be modified. \"\n \"b. “&str” is a primitive data type, whereas “String” is implemented in the standard library.\"\n \"c. To read a file into the strings, we use the read_to_string() method.\"\n",
          "hint": "NoHint",
          "explanation": "Strings are mutable in nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Only a",
              "key": "A"
            },
            {
              "content": "Both a & b",
              "key": "B"
            },
            {
              "content": "Both b & c",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9511276a-dd19-47c4-b086-0d1de8cafedb",
          "type": "SingleChoice",
          "content": "Which among the following is not an acceptable keyword in rust?",
          "hint": "NoHint",
          "explanation": "var is not a keyword in rust",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "let",
              "key": "A"
            },
            {
              "content": "var",
              "key": "B"
            },
            {
              "content": "impl",
              "key": "C"
            },
            {
              "content": "mut",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1ed70de2-99c6-43dd-8793-40ad702d6bff",
          "type": "SingleChoice",
          "content": "Which of the following brackets are used as placeholders in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "{}",
              "key": "A"
            },
            {
              "content": "[ ]",
              "key": "B"
            },
            {
              "content": "( )",
              "key": "C"
            },
            {
              "content": "< >",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7f129510-4d19-4a62-bae1-34109714fa0e",
          "type": "SingleChoice",
          "content": "Constants in rust can be defined in which scope?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Global",
              "key": "A"
            },
            {
              "content": "Method",
              "key": "B"
            },
            {
              "content": "Local",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b29fa10c-2efa-478c-8207-2e2a80af8700",
          "type": "SingleChoice",
          "content": "Which of the following are the scalar data types present in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "integers, floating-point numbers, booleans, characters",
              "key": "A"
            },
            {
              "content": "integers, signed numbers, unsigned numbers, booleans, characters",
              "key": "B"
            },
            {
              "content": "integers, strings, signed numbers, unsigned numbers, booleans",
              "key": "C"
            },
            {
              "content": "integers, floating-point numbers, strings, booleans",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "775949c1-23b7-42bc-b184-bc755c8d2657",
          "type": "SingleChoice",
          "content": "The compound data types supported by rust are-",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays, Lists, Red-Black Trees",
              "key": "A"
            },
            {
              "content": "Arrays, Lists, Vectors",
              "key": "B"
            },
            {
              "content": "Arrays, Tuples",
              "key": "C"
            },
            {
              "content": "Arrays, Maps",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7fd341f0-4921-4e6e-aa0c-c3897f91d3b2",
          "type": "SingleChoice",
          "content": "Which are valid array declarations in rust? \n``` \n       let mut arr : {i64, 3} = [2,3,5];\n       let mut arr : {3,3};\n       let mut arr = [2,3,5];\n ```\n",
          "hint": "Look for the wrong declaration format, you may or may not find it",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both a & b",
              "key": "A"
            },
            {
              "content": "Both b & c",
              "key": "B"
            },
            {
              "content": "Only a",
              "key": "C"
            },
            {
              "content": "All a, b, & c",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "75d926cd-6f05-4185-916c-fc6c2b90eecd",
          "type": "SingleChoice",
          "content": "Which of the following has low memory usage, const or static?",
          "hint": "How many of these can we update?",
          "explanation": "Constant doesn't uses any extra heap memory to update",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "const",
              "key": "A"
            },
            {
              "content": "static",
              "key": "B"
            },
            {
              "content": "depends upon the data type",
              "key": "C"
            },
            {
              "content": "both have the same memory usage",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a7495120-1470-41d4-aeb2-6d9d7ebd876c",
          "type": "SingleChoice",
          "content": "To use dynamic-sized variables, which of the following should be used?",
          "hint": "No hint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Arrays & Tuples",
              "key": "A"
            },
            {
              "content": "List all the data types",
              "key": "B"
            },
            {
              "content": "Sized",
              "key": "C"
            },
            {
              "content": "Dynamic-Sized variables not supported in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4c564a7d-28d3-4fca-a06d-f3f3fc419d13",
          "type": "SingleChoice",
          "content": "What is the importance of the “type” keyword in rust?",
          "hint": "Used for another types.",
          "explanation": "Sets an alias of another type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "used for dynamic-sized data type",
              "key": "A"
            },
            {
              "content": "used to create a template",
              "key": "B"
            },
            {
              "content": "used for user-defined data type",
              "key": "C"
            },
            {
              "content": "used to set an alias of another type",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d677a228-7f5d-4b5f-8bee-9f40052efafb",
          "type": "SingleChoice",
          "content": "What is the importance of Cargo in rust?",
          "hint": "What is npm used for?",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "package-manager"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Collection of rust libraries",
              "key": "A"
            },
            {
              "content": "Modules Package manager",
              "key": "B"
            },
            {
              "content": "Build system and Package manager",
              "key": "C"
            },
            {
              "content": "Used to create and build UI projects in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2715ab2c-35b3-4e6a-9697-f244c6e23676",
          "type": "SingleChoice",
          "content": "How to print the data type of a variable in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": " `std::any::type_name` ",
              "key": "A"
            },
            {
              "content": " `variable.type_name()` ",
              "key": "B"
            },
            {
              "content": " `std::intrisic::type_name` ",
              "key": "C"
            },
            {
              "content": " `std::variable::type_name` ",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e326751d-bb65-44e4-a6ce-fa62faa96f94",
          "type": "SingleChoice",
          "content": "Which type cast preserves the mathematical value in all cases?",
          "hint": "NoHint",
          "explanation": "Because they can handle both signed and unsigned values, and are typecasted in one data type only.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "i32 as i64",
              "key": "A"
            },
            {
              "content": "i64 as i32",
              "key": "B"
            },
            {
              "content": "usize as u64",
              "key": "C"
            },
            {
              "content": "f64 as f32",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ffac79fe-2367-42d1-82eb-b6e6127aead5",
          "type": "SingleChoice",
          "content": "Which of the following cannot be destructed further into smaller segments?",
          "hint": "Think of the structures they're built upon ",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Tuples",
              "key": "A"
            },
            {
              "content": "Traits",
              "key": "B"
            },
            {
              "content": "Arrays",
              "key": "C"
            },
            {
              "content": "Structs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b0a3444-3b86-4e09-8021-f4b66cb2ce09",
          "type": "SingleChoice",
          "content": "Which comment syntax is not legal?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "<//>",
              "key": "A"
            },
            {
              "content": "/* */",
              "key": "B"
            },
            {
              "content": "//!",
              "key": "C"
            },
            {
              "content": "//",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f9d0f0d-4670-44d7-b69f-d398ecfb3236",
          "type": "SingleChoice",
          "content": "Values of the array can be deleted.",
          "hint": "NoHint",
          "explanation": "Values can be updated, but can't be deleted",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d2af3b88-9912-4729-9673-4101b7ec4765",
          "type": "SingleChoice",
          "content": "How do you initialize every element of an array of size 5 with 0?",
          "hint": "Look at the declarations, don't get confused by the order while declaring",
          "explanation": "The first argument is the integer you want to initialize an element with, and the second argument tells the end posistion till where you want to pre-initialize.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "`let mut arr : {i32;5} = {5;0};`",
              "key": "A"
            },
            {
              "content": "`let mut arr : {i32;5} = {0;5};`",
              "key": "B"
            },
            {
              "content": "`let mut arr : {5;i32} = {5;0};`",
              "key": "C"
            },
            {
              "content": "`let mut arr : {5;i32} = {0;5};`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "93c0673c-a86b-4bbb-82b0-3bb77bddab67",
          "type": "SingleChoice",
          "content": "Tuples in rust are",
          "hint": "NoHint",
          "explanation": "They can handle and store different data types",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "finite heterogeneous compound data types",
              "key": "A"
            },
            {
              "content": "finite homogeneous compound data types",
              "key": "B"
            },
            {
              "content": "infinite heterogeneous compound data types",
              "key": "C"
            },
            {
              "content": "infinite homogeneous compound data types",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8c7f2429-0db2-4288-bd4a-ef694b39206c",
          "type": "SingleChoice",
          "content": "What would be the output of the following code snippet?\n  ```\n    Fn main( ) {\t\n      let mut dodao_io = (\"\"Do\"\", 69, \"\"DAO\"\", 420);\n      println!(\"\"{} \"\", dodao_io );\n      println!(\"\"at 0 index = {} \"\", gfg.0 );\n    } \n  ```\n",
          "hint": "No Hint",
          "explanation": "The first print statement should've had {;?}",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & Do",
              "key": "A"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) only",
              "key": "B"
            },
            {
              "content": "Compilation Error",
              "key": "C"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & “Do”",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f6ce66c-3d34-4fa0-b6f6-188b7aa052b9",
          "type": "SingleChoice",
          "content": "What is the process of temporarily making a variable mutable known as?",
          "hint": "NoHint",
          "explanation": "No explantion",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Pseudo-mutability",
              "key": "A"
            },
            {
              "content": "Foreshadowing",
              "key": "B"
            },
            {
              "content": "Shadowing",
              "key": "C"
            },
            {
              "content": "Overshadowing",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d8a49f56-5da8-4b71-b18c-e745d5913dee",
          "type": "SingleChoice",
          "content": "Which of the following is an example of suffix annotation?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let a_int: i64 = 20;",
              "key": "A"
            },
            {
              "content": "let a_int = i6420;",
              "key": "B"
            },
            {
              "content": "let a_int = 20i64;",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "419058bf-87e9-4c18-9b8e-3f96c3c820b3",
          "type": "SingleChoice",
          "content": "A. println!(\"1 + 2 = {}\", 1u32 + 2);\nB. println!(\"1 - 2 = {}\", 1u32 + 2);\n",
          "hint": "Solution being Positive or Negative might make a difference",
          "explanation": "Here, when initialized, 1 is set as unsigned 32 integer u32. In statement A, it works because  1+2=3, and it's positive. But, 1-2=(-1) and as they were unsigned integers, so they cannot hold a negative value, so this statement doesn't compile\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Only A compiles",
              "key": "A"
            },
            {
              "content": "Only B compiles",
              "key": "B"
            },
            {
              "content": "Both A & B compile",
              "key": "C"
            },
            {
              "content": "None of them complies",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d97fc146-6c06-4a5c-a738-93a00cf7214e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n\"``` println!(\"{}\", 1_00u32 + 2_0); ```\"\n",
          "hint": "NoHint",
          "explanation": "1_000u32 is similar as 100 of u32 type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Compilation Error",
              "key": "A"
            },
            {
              "content": "Runtime Error",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "120",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2448d741-4c38-46f3-b681-c3ffb44e54ac",
          "type": "SingleChoice",
          "content": "String in standard library has more functionalities coded into it than string slice?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "923d11ba-5c1c-4d48-8101-87ee08e0fa0e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n  ```\n  fn main() {\n    let first_string = \"This is some string \".to_string();\n    let second_string = \"Let's add some Data\";\n\n    let final_string = first_string + &second_string;\n\n    println!(\"First string is: {}\", first_string);   \n    println!(\"Second string is: {}\", second_string);\n\n    println!(\"Finally we have: {}\", final_string);\n  }\n  ```\n",
          "hint": "NoHint",
          "explanation": "Syntatical Error in the code snippet",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Only 1st print statement shows an output",
              "key": "A"
            },
            {
              "content": "Only 1st and 2nd print statement shows an output",
              "key": "B"
            },
            {
              "content": "All the 3 string statements show an output",
              "key": "C"
            },
            {
              "content": "Error occurs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ec5e9c9b-cafa-484e-8feb-51db5a0b7a33",
          "type": "SingleChoice",
          "content": "Which of the following operator is used by string slices to reference?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`&`",
              "key": "A"
            },
            {
              "content": "`%`",
              "key": "B"
            },
            {
              "content": "`#`",
              "key": "C"
            },
            {
              "content": "`*`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d0b24301-eda6-49d7-bf45-88777b13e15f",
          "type": "SingleChoice",
          "content": "Select the incorrect statement from the following",
          "hint": "Nohint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Once you get a string slice from a string, then you cannot really                 modify that String anymore",
              "key": "A"
            },
            {
              "content": "Using slices to work with Strings allows us to add an extra                       security measure.",
              "key": "B"
            },
            {
              "content": "If you attempt to create a string slice in the middle of a                        multibyte character, your program will exit with an error",
              "key": "C"
            },
            {
              "content": "String Slice mutably borrows the String itself",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ef79a0da-3da6-445e-92b5-1d0e17799db6",
          "type": "SingleChoice",
          "content": "What will happen at the runtime if overflow occurs?",
          "hint": "NoHint",
          "explanation": "The memory stack is full and overflows, so a default panic occurs                 and the program crashes",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Panic and crashes the program",
              "key": "A"
            },
            {
              "content": "Garbage values will be output",
              "key": "B"
            },
            {
              "content": "Those values are ignored and the output is as expected",
              "key": "C"
            },
            {
              "content": "Overflow is handled already by rust, so it doesn’t occur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b152ab5-6524-49e0-b5c0-8bd5153b1ab1",
          "type": "SingleChoice",
          "content": "Character literals are specified using double quotes, as opposed to single quotes which stand for string literals.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "strings",
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "b49785fb-dd24-43b5-9f5a-e7dedc98cc5f",
          "type": "SingleChoice",
          "content": "Strings size is not known at compile time",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "504040ac-6167-4304-8d6e-1e559975bac5",
          "type": "SingleChoice",
          "content": "For the following code\n ```  \n   fn main() {\n     let mut x = 2.0;\n     x: i32= 3.0; \n   }\n ```\n",
          "hint": "type declaration",
          "explanation": "i32 is intialized as a float data type",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The code compiles without errors",
              "key": "A"
            },
            {
              "content": "The code has errors because of immutability",
              "key": "B"
            },
            {
              "content": "The code has errors because of illegal type conversion",
              "key": "C"
            },
            {
              "content": "The code has errors because of no print and return statements",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0ef2f16-b79d-433a-af54-dc218060ef13",
          "type": "SingleChoice",
          "content": "If you want to store boolean values with the provision of adding more             values at runtime, the most suitable way would be to use",
          "hint": "Statically and Dynamic in nature",
          "explanation": "Vector is a Dynamic nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays",
              "key": "A"
            },
            {
              "content": "Tuples",
              "key": "B"
            },
            {
              "content": "Vectors",
              "key": "C"
            },
            {
              "content": "bool type Variables",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c731455f-5296-4b1f-9aee-46a4f77c25c1",
          "type": "SingleChoice",
          "content": "BOOLEAN is a type of data type that basically gives a tautology or                fallacy.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "f8497eb4-2e55-4e70-98c9-b395f254f412",
          "type": "SingleChoice",
          "content": "What are the categories in which keywords are divided in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Weak",
              "key": "A"
            },
            {
              "content": "Strict",
              "key": "B"
            },
            {
              "content": "Reserved",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "836ae5f7-8e1d-41ad-a0b9-e0ce810cbf93",
          "type": "SingleChoice",
          "content": "Which of the following can be used as a variable name in rust?",
          "hint": "NoHint",
          "explanation": "Rest are keywords in rust",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables",
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "crate",
              "key": "A"
            },
            {
              "content": "match",
              "key": "B"
            },
            {
              "content": "await",
              "key": "C"
            },
            {
              "content": "tuple",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "853bbf17-ceb6-4a7c-9a32-c05f048a9ce6",
          "type": "SingleChoice",
          "content": "Identify the wrong set of rust keywords",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "async, await, where, use",
              "key": "A"
            },
            {
              "content": "Move, return, mut, while",
              "key": "B"
            },
            {
              "content": "union, dyn, try, abstract",
              "key": "C"
            },
            {
              "content": "become, box, do, incur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "118287fb-f962-4c6a-b7bb-f774e36f02bf",
          "type": "SingleChoice",
          "content": "Rust variable names can start with",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Letter, underscore",
              "key": "A"
            },
            {
              "content": "Letter, digits",
              "key": "B"
            },
            {
              "content": "Underscore, digits",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6ffbcd01-5b77-44bd-a9e1-56d3adb81a61",
          "type": "SingleChoice",
          "content": "q What is the result of the following calculation in rust \"1.0/0.0\"\n",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A positive number",
              "key": "A"
            },
            {
              "content": "A negative number",
              "key": "B"
            },
            {
              "content": "An unsigned number",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e8c7d69e-3899-43aa-aaec-e45870a32a3f",
          "type": "SingleChoice",
          "content": "In Rust, every value has its data type. The data type tells the compiler what kind of value it is and how to use it.",
          "hint": "noHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "699f89a5-4c2a-4442-afe7-eabc1fb8f5fa",
          "title": "Introduction to Blockchain Technology",
          "shortTitle": "Intro Blockchain",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=u70_rafPs-0",
          "subTopics": [
            "variables"
          ],
          "details": "This video explains about\n* Point 1\n* Point 2\n"
        }
      ],
      "summaries": [
        {
          "title": "Typed language",
          "shortTitle": "Typed language",
          "key": "typed_language",
          "details": "- Dynamically-Typed Languages\n  * Dynamically-typed languages are the languages where the interpreter assigns variables a data type at runtime based on the variable's value at that time.\n  * Dynamic languages are usually interpreted (with some pre-processing for optimisation) so it is fast to make changes and then immediately run the updated program.\n  * Dynamically-Typed languages allows for Fast Development Cycles and Fast Start-up times.\n  * Some Examples of Dynamically Typed Languages are:- JavaScript, Python, Perl, Ruby, etc.\n- Statically-Typed Languages\n  * Statically-typed languages are the languages where variable types are known at compile time i.e. the type checking is done at compile time.\n  * Many runtime errors become compile time errors as the compiler ensures that you are writing 'correct' code. This leads to a much smoother development experience.\n  * The execution of the code will be faster compared to the dynamically-typed languages.\n  * The compiler can use the type system to provide language features that are more expressive and succinct.\n  * Some examples of Statically-Typed Languages are:- C++, Rust, C, Java, etc.\n- Rust is a Statically-Typed Language\n"
        },
        {
          "title": "Value Types",
          "shortTitle": "Value Types",
          "key": "value-types",
          "details": "- Rust has two major Data Value Types, which include \n    1. Scalar Types\n    2. Compound ypes\n- Scalar Types\n  * A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.\n  - Integers\n    * An integer is a number without a fractional component.\n    * An integer can be of the following sizes:- 8-bit, 16-bit, 32-bit, 64-bit, 128-bit, arch.\n    * Integers can be either signed or unsigned. Signed and unsigned refer to whether it’s possible for the number to be negative—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned).\n    * Integers can be declared using keyword let, and explicitly defining the variable size and it's type of signed or unsigned integer.\n    * For example, we can declare a 64-bit signed and 32-bit unsigned integer in the following ways respectively :- \n    ```\n        1. let mut x: i64 = -20;\n        2. let mut x: u32 = 20;\n    ```\n    * The isize and usize types depend on the architecture of your build, which is denoted in the table as “arch”: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit architecture.\n    * The number literals that can be multiple numeric types allow a type suffix, such as `20u32`, to designate the type. Number literals can also use `_` as a visual separator to make the number easier to read, such as `1_000` , which will have the same value as if you had specified `1000`.\n    - Integer Overflow\n      * Let's say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, integer overflow will occur, which can result in one of two behaviors:- \n        1. When you're compiling in `debug` mode, Rust includes checks for integer overflow that cause your program to panic at runtime if this behavior occurs.\n        2. When you're compiling in release mode with the `--release` flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping.\n  - Floating-Point Types\n    * Floating-Point Types are number with the decimal points.\n    * Floating-point types are f32 and f64, which are 32 bits and 64 bits in size, respectively.\n    * All the Floating-Point Types are signed.\n    * The default Floating-Point Type is of 64-bit.\n    * The `f32` type is a single-precision float, and `f64` has double precision.\n    * We can declare a float type variable in the following ways:- \n     ```\n        fn main() {\n              let x = 2.0; // f64\n              let y: f32 = 3.0; // f32\n        }\n      ```\n  - Boolean Type\n    * There are two possible constant values:- True & False.\n    * Booleans are one byte in size.\n    * They are declared using the keyword 'bool'.\n  - Character Type\n    * Character Data Type doesn't use ASCII values like other programming languages but uses Unicode Scalar Value.\n    * It uses 4 bytes i.e. 32 bits of space for each character rather than 1 byte because of Unicode Scalar Values.\n    * We can use many more types of characters in rust, like, Chinese, emojis, etc.\n- Compound Data Types\n  * Compound types can group multiple values into one type. The two primitive compound types in rust are: Tuples and Arrays.\n  - Tuples\n    * A tuple is a general way of grouping together a number of values with a variety of types into one compound type.\n    * Tuples have a fixed length: once declared, they cannot grow or shrink in size.\n    * Tuples are created by a comma seperated List.\n    * Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same.\n    * For Example:- \n      ```\n        fn main() {\n          let tup: (i32, f64, u8) = (500, 6.4, 1);\n        }\n      ```\n    * We can access a tuple element directly by using a period `(.)` followed by the index of the value we want to access\n    * The tuple without any values has a special name knows as \"unit\".\n    * \"unit's\" value and its corresponding type are both written () and represent an empty value or an empty return type. \n    * Expressions implicitly return the unit value if they don’t return any other value. \n  - Arrays\n    * Arrays are a collection of multiple values, stored in a single entity.\n    * Unlike a tuple, every element of an array must have the same data type.\n    * Arrays in Rust have a fixed length, i.e. they are not dynamic in nature by default.\n    * Arrays are useful when you want your data allocated on the stack rather than the memory heap.\n    * For Example:- \n      ```\n        fn main() {\n            let a: [i32; 5] = [1, 2, 3, 4, 5];\n        }\n      ```\n      Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.\n    *  We can access elements of an array using indexing, like this:\n      ```\n        fn main() {\n            let a = [1, 2, 3, 4, 5];\n        \n            let first = a[0]; // outputs 1\n            let second = a[1]; // outputs 2\n        }\n      ```\n"
        },
        {
          "title": "Variables",
          "shortTitle": "Variables",
          "key": "variables",
          "details": "- Variables are used to store the values of a particular data type\n- Variables and Mutability\n  * In Rust, variables are immutable in nature by default.\n  * When a variable is immutable, once a value is bound to a name, you can’t change that value\n  * To make the variables mutable, we use the keyword:- `mut`.\n  * For Example:-\n    ```\n      fn main() {\n          let mut x = 5;\n          println!(\"The value of x is: {x}\");\n          x = 6;\n          println!(\"The value of x is: {x}\");\n      }\n    ```\n- Constants\n  * Constants are values that are bound to a name and are not allowed to change, i.e. they are also immutable.\n  * Usage of keyword `mut` isn't allowed with constants.\n  * Constants are immutable by default, and also they’re always immutable.\n  * We declare constants using the `const` keyword instead of the `let` keyword, and the type of the value must be annotated.\n  * Constants can be declared in any scope, including the global scope, making them useful for values that many parts of code need to know about.\n  * Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.\n  * For Example:-\n    ```\n      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n    ```\n"
        },
        {
          "title": "Keywords",
          "shortTitle": "Keywords",
          "key": "keywords",
          "details": "- Keywords are predefined, reserved words used in programming that have special meanings to the compiler. Rust divides keywords into three categories:\n    1. Strict\n    2. Reserved \n    3. Weak\n- Strict Keywords\n  * These keywords can only be used in their correct contexts. They cannot be used as the names of: Items, Variables and function parameters, etc.\n  * For Example:- ` mut, break, else, continue, return, impl, etc. ` \n- Reserved Variables\n  * These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords.\n  * For Example:- ` abstract, try, do, final, typeof, etc. `\n- Weak Keywords\n  * These keywords have special meaning only in certain contexts.\n  * For example, it is possible to declare a variable or method with the name `union`.\n"
        },
        {
          "title": "Bit Manipulation",
          "shortTitle": "Bit Manipulation",
          "key": "bit-manupilation",
          "details": "- Bit manipulation is the process of applying logical operations on a sequence of bits to achieve a required result.\n- Bit Mnipulation is strictly done by rust compilers for storing data in variables, for two's compliment and many other purposes.\n"
        },
        {
          "title": "Strings",
          "shortTitle": "Strings",
          "key": "strings",
          "details": "- There are two types of strings in Rust: `String` and `&str`.\n- String\n  * Strings are formed by a list of characters, which is really an \"array of characters\".\n  * A String is stored as a vector of bytes `(Vec<u8>)`.\n  * A String is made up of three components: a pointer to some bytes, a length, and a capacity.\n  * The pointer points to an internal buffer String uses to store its data.\n  * The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.\n  * The buffer is always stored on the heap.\n  * It is guaranteed to always be a valid `UTF-8` sequence. \n  * String is heap allocated, growable and not null terminated.\n  * We can create a String from a literal string with `String::from`\n  * We can append a char to a String with the push method, and append a &str with the `push_str` method\n- &str\n  * The str type, also called a 'string slice', is the most primitive string type.\n  * A &str is made up of two components: a pointer to some bytes, and a length.\n  * `&str` is `(&[u8])` that always points to a valid UTF-8 sequence.\n  * It can be used to view into a String, just like `&[T]` is a view into `Vec<T>`.\n"
        },
        {
          "title": "Package Manager",
          "shortTitle": "Package Manager",
          "key": "package-manager",
          "details": "- A package manager or package-management system is a collection of software tools that automates the process of installing, upgrading, configuring, and removing computer programs for a computer in a consistent manner.\n- Cargo is the Rust package manager.\n"
        }
      ]
    },
    {
      "title": "Data Types",
      "key": "first-smart-contract",
      "details": "This chapter covers all in-depth knowledge about variables, mutability, and the various data types available in rust. Covered topics in this chapter\n - Variables and Immutability\n    1. How to declare variables\n    2. How mut works\n    3. Constants\n    4. Shadowing\n - Different Data Types\n    1. Scalar Data Types\n    2. Compound Data Types\n - Scalar Data Type\n    1. Integer Types\n      a. Signed and Unsigned Integers\n      b. Allowed integer sizes in rust\n      c. Declaration and Rules for Integers\n    2. Floating-Point Types\n      a. Types of Floating-points available\n      b. Declaration and Rules for Floating-Points\n    3. Boolean Types\n      a. Types of booleans\n      b. Declaration and Rules\n    4. Characters\n      a. ASCII vs Unicode Scalar Values\n      b. How character types in rust are different\n  - Compound Data Types\n    1. Arrays\n      a. When and how to use Arrays\n      b. Declaration and general rules for Arrays\n    2. Tuples\n      a. When and how to use Tuples\n      b. Declaration and general rules for Tuples\n      c. Difference between Arrays and Tuples.\n  - Strings\n    1. UTF8 set\n    2. Owned Strings: \"String\"\n    3. String Slice: \"&str\"\n    4. Difference between \"String\" and \"&str\"\n",
      "order": 1,
      "questions": [
        {
          "uuid": "ab88a2ab-c80b-49f5-9ea0-b5ed8e4933b1",
          "type": "SingleChoice",
          "content": "What is the output of the following code snippet:\n \n    ``` \n        fn main() {\n          let x = 12;\n          println!(\"The value of x is: {x}\");\n          x = 8;\n          println!(\"The value of x is: {x}\");\n        } \n    ```\n",
          "hint": "NoHint",
          "explanation": "Error would occur, because the variable x isn't set as mutable so it's value can't be changed.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The value of x is: 8",
              "key": "A"
            },
            {
              "content": "Error: the variable x is mutable",
              "key": "B"
            },
            {
              "content": "The value of x is: 12",
              "key": "C"
            },
            {
              "content": "Error: the variable x is immutable",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "23a0e9e5-6c47-4512-98a5-4cd3ab6eff25",
          "type": "SingleChoice",
          "content": "Space taken by a Character data type in rust is",
          "hint": "It doesn't use ASCII values",
          "explanation": "Rust's char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1 byte",
              "key": "A"
            },
            {
              "content": "4 bytes",
              "key": "B"
            },
            {
              "content": "8 bytes",
              "key": "C"
            },
            {
              "content": "16 bytes",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "39385b22-7604-492f-9c2e-aaae409c6b79",
          "type": "SingleChoice",
          "content": "Rust is a Dynamically typed language.",
          "hint": "Does the compiler need to know the data type at compile time?",
          "explanation": "It is statically typed",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "6b844c24-f769-4662-a591-83c0a5f8c6c3",
          "type": "SingleChoice",
          "content": "Select the incorrect declaration statement",
          "hint": "NoHint",
          "explanation": "It is declared as an unsigned integer, but the value is negative",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let mut x: u32 = 20;",
              "key": "A"
            },
            {
              "content": "let mut x: i32 = -20;",
              "key": "B"
            },
            {
              "content": "let mut x: u32 = -20;",
              "key": "C"
            },
            {
              "content": "let mut x = 20;",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6f2cb4ae-db4d-4c04-bfd4-37669695dab0",
          "type": "SingleChoice",
          "content": "Suppose you declared a variable as u8 and then assigned it a value of \"257\". What would be the output if it’s compiled with a \"`“--release” flag?`\"",
          "hint": "NoHint",
          "explanation": "After 255 the digits start rolling back to 0, 1 and so on",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "257",
              "key": "A"
            },
            {
              "content": "Error: Integer Overflow",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0708f185-46b5-45ee-ac47-3e7e1ca611b3",
          "type": "SingleChoice",
          "content": "Are Tuples in rust dynamic in nature?\n\"Eg:-\" \n``` \n  let tup: (i32, f64, bool) = (500, 6.4, true); \n```\n",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Yes",
              "key": "A"
            },
            {
              "content": "No",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d11a531f-f32f-4764-a60a-2cc5af348245",
          "type": "SingleChoice",
          "content": "Select the correct statements for the two String     types(“String” and “&str”).\n \"a. “Strings” are immutable in nature and cannot be modified. \"\n \"b. “&str” is a primitive data type, whereas “String” is implemented in the standard library.\"\n \"c. To read a file into the strings, we use the read_to_string() method.\"\n",
          "hint": "NoHint",
          "explanation": "Strings are mutable in nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Only a",
              "key": "A"
            },
            {
              "content": "Both a & b",
              "key": "B"
            },
            {
              "content": "Both b & c",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9511276a-dd19-47c4-b086-0d1de8cafedb",
          "type": "SingleChoice",
          "content": "Which among the following is not an acceptable keyword in rust?",
          "hint": "NoHint",
          "explanation": "var is not a keyword in rust",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "let",
              "key": "A"
            },
            {
              "content": "var",
              "key": "B"
            },
            {
              "content": "impl",
              "key": "C"
            },
            {
              "content": "mut",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1ed70de2-99c6-43dd-8793-40ad702d6bff",
          "type": "SingleChoice",
          "content": "Which of the following brackets are used as placeholders in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "{}",
              "key": "A"
            },
            {
              "content": "[ ]",
              "key": "B"
            },
            {
              "content": "( )",
              "key": "C"
            },
            {
              "content": "< >",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7f129510-4d19-4a62-bae1-34109714fa0e",
          "type": "SingleChoice",
          "content": "Constants in rust can be defined in which scope?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Global",
              "key": "A"
            },
            {
              "content": "Method",
              "key": "B"
            },
            {
              "content": "Local",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b29fa10c-2efa-478c-8207-2e2a80af8700",
          "type": "SingleChoice",
          "content": "Which of the following are the scalar data types present in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "integers, floating-point numbers, booleans, characters",
              "key": "A"
            },
            {
              "content": "integers, signed numbers, unsigned numbers, booleans, characters",
              "key": "B"
            },
            {
              "content": "integers, strings, signed numbers, unsigned numbers, booleans",
              "key": "C"
            },
            {
              "content": "integers, floating-point numbers, strings, booleans",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "775949c1-23b7-42bc-b184-bc755c8d2657",
          "type": "SingleChoice",
          "content": "The compound data types supported by rust are-",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays, Lists, Red-Black Trees",
              "key": "A"
            },
            {
              "content": "Arrays, Lists, Vectors",
              "key": "B"
            },
            {
              "content": "Arrays, Tuples",
              "key": "C"
            },
            {
              "content": "Arrays, Maps",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7fd341f0-4921-4e6e-aa0c-c3897f91d3b2",
          "type": "SingleChoice",
          "content": "Which are valid array declarations in rust? \n``` \n       let mut arr : {i64, 3} = [2,3,5];\n       let mut arr : {3,3};\n       let mut arr = [2,3,5];\n ```\n",
          "hint": "Look for the wrong declaration format, you may or may not find it",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both a & b",
              "key": "A"
            },
            {
              "content": "Both b & c",
              "key": "B"
            },
            {
              "content": "Only a",
              "key": "C"
            },
            {
              "content": "All a, b, & c",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "75d926cd-6f05-4185-916c-fc6c2b90eecd",
          "type": "SingleChoice",
          "content": "Which of the following has low memory usage, const or static?",
          "hint": "How many of these can we update?",
          "explanation": "Constant doesn't uses any extra heap memory to update",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "const",
              "key": "A"
            },
            {
              "content": "static",
              "key": "B"
            },
            {
              "content": "depends upon the data type",
              "key": "C"
            },
            {
              "content": "both have the same memory usage",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a7495120-1470-41d4-aeb2-6d9d7ebd876c",
          "type": "SingleChoice",
          "content": "To use dynamic-sized variables, which of the following should be used?",
          "hint": "No hint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Arrays & Tuples",
              "key": "A"
            },
            {
              "content": "List all the data types",
              "key": "B"
            },
            {
              "content": "Sized",
              "key": "C"
            },
            {
              "content": "Dynamic-Sized variables not supported in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4c564a7d-28d3-4fca-a06d-f3f3fc419d13",
          "type": "SingleChoice",
          "content": "What is the importance of the “type” keyword in rust?",
          "hint": "Used for another types.",
          "explanation": "Sets an alias of another type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "used for dynamic-sized data type",
              "key": "A"
            },
            {
              "content": "used to create a template",
              "key": "B"
            },
            {
              "content": "used for user-defined data type",
              "key": "C"
            },
            {
              "content": "used to set an alias of another type",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d677a228-7f5d-4b5f-8bee-9f40052efafb",
          "type": "SingleChoice",
          "content": "What is the importance of Cargo in rust?",
          "hint": "What is npm used for?",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "package-manager"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Collection of rust libraries",
              "key": "A"
            },
            {
              "content": "Modules Package manager",
              "key": "B"
            },
            {
              "content": "Build system and Package manager",
              "key": "C"
            },
            {
              "content": "Used to create and build UI projects in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2715ab2c-35b3-4e6a-9697-f244c6e23676",
          "type": "SingleChoice",
          "content": "How to print the data type of a variable in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": " `std::any::type_name` ",
              "key": "A"
            },
            {
              "content": " `variable.type_name()` ",
              "key": "B"
            },
            {
              "content": " `std::intrisic::type_name` ",
              "key": "C"
            },
            {
              "content": " `std::variable::type_name` ",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e326751d-bb65-44e4-a6ce-fa62faa96f94",
          "type": "SingleChoice",
          "content": "Which type cast preserves the mathematical value in all cases?",
          "hint": "NoHint",
          "explanation": "Because they can handle both signed and unsigned values, and are typecasted in one data type only.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "i32 as i64",
              "key": "A"
            },
            {
              "content": "i64 as i32",
              "key": "B"
            },
            {
              "content": "usize as u64",
              "key": "C"
            },
            {
              "content": "f64 as f32",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ffac79fe-2367-42d1-82eb-b6e6127aead5",
          "type": "SingleChoice",
          "content": "Which of the following cannot be destructed further into smaller segments?",
          "hint": "Think of the structures they're built upon ",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Tuples",
              "key": "A"
            },
            {
              "content": "Traits",
              "key": "B"
            },
            {
              "content": "Arrays",
              "key": "C"
            },
            {
              "content": "Structs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b0a3444-3b86-4e09-8021-f4b66cb2ce09",
          "type": "SingleChoice",
          "content": "Which comment syntax is not legal?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "<//>",
              "key": "A"
            },
            {
              "content": "/* */",
              "key": "B"
            },
            {
              "content": "//!",
              "key": "C"
            },
            {
              "content": "//",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f9d0f0d-4670-44d7-b69f-d398ecfb3236",
          "type": "SingleChoice",
          "content": "Values of the array can be deleted.",
          "hint": "NoHint",
          "explanation": "Values can be updated, but can't be deleted",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d2af3b88-9912-4729-9673-4101b7ec4765",
          "type": "SingleChoice",
          "content": "How do you initialize every element of an array of size 5 with 0?",
          "hint": "Look at the declarations, don't get confused by the order while declaring",
          "explanation": "The first argument is the integer you want to initialize an element with, and the second argument tells the end posistion till where you want to pre-initialize.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "`let mut arr : {i32;5} = {5;0};`",
              "key": "A"
            },
            {
              "content": "`let mut arr : {i32;5} = {0;5};`",
              "key": "B"
            },
            {
              "content": "`let mut arr : {5;i32} = {5;0};`",
              "key": "C"
            },
            {
              "content": "`let mut arr : {5;i32} = {0;5};`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "93c0673c-a86b-4bbb-82b0-3bb77bddab67",
          "type": "SingleChoice",
          "content": "Tuples in rust are",
          "hint": "NoHint",
          "explanation": "They can handle and store different data types",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "finite heterogeneous compound data types",
              "key": "A"
            },
            {
              "content": "finite homogeneous compound data types",
              "key": "B"
            },
            {
              "content": "infinite heterogeneous compound data types",
              "key": "C"
            },
            {
              "content": "infinite homogeneous compound data types",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8c7f2429-0db2-4288-bd4a-ef694b39206c",
          "type": "SingleChoice",
          "content": "What would be the output of the following code snippet?\n  ```\n    Fn main( ) {\t\n      let mut dodao_io = (\"\"Do\"\", 69, \"\"DAO\"\", 420);\n      println!(\"\"{} \"\", dodao_io );\n      println!(\"\"at 0 index = {} \"\", gfg.0 );\n    } \n  ```\n",
          "hint": "No Hint",
          "explanation": "The first print statement should've had {;?}",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & Do",
              "key": "A"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) only",
              "key": "B"
            },
            {
              "content": "Compilation Error",
              "key": "C"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & “Do”",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f6ce66c-3d34-4fa0-b6f6-188b7aa052b9",
          "type": "SingleChoice",
          "content": "What is the process of temporarily making a variable mutable known as?",
          "hint": "NoHint",
          "explanation": "No explantion",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Pseudo-mutability",
              "key": "A"
            },
            {
              "content": "Foreshadowing",
              "key": "B"
            },
            {
              "content": "Shadowing",
              "key": "C"
            },
            {
              "content": "Overshadowing",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d8a49f56-5da8-4b71-b18c-e745d5913dee",
          "type": "SingleChoice",
          "content": "Which of the following is an example of suffix annotation?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let a_int: i64 = 20;",
              "key": "A"
            },
            {
              "content": "let a_int = i6420;",
              "key": "B"
            },
            {
              "content": "let a_int = 20i64;",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "419058bf-87e9-4c18-9b8e-3f96c3c820b3",
          "type": "SingleChoice",
          "content": "A. println!(\"1 + 2 = {}\", 1u32 + 2);\nB. println!(\"1 - 2 = {}\", 1u32 + 2);\n",
          "hint": "Solution being Positive or Negative might make a difference",
          "explanation": "Here, when initialized, 1 is set as unsigned 32 integer u32. In statement A, it works because  1+2=3, and it's positive. But, 1-2=(-1) and as they were unsigned integers, so they cannot hold a negative value, so this statement doesn't compile\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Only A compiles",
              "key": "A"
            },
            {
              "content": "Only B compiles",
              "key": "B"
            },
            {
              "content": "Both A & B compile",
              "key": "C"
            },
            {
              "content": "None of them complies",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d97fc146-6c06-4a5c-a738-93a00cf7214e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n\"``` println!(\"{}\", 1_00u32 + 2_0); ```\"\n",
          "hint": "NoHint",
          "explanation": "1_000u32 is similar as 100 of u32 type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Compilation Error",
              "key": "A"
            },
            {
              "content": "Runtime Error",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "120",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2448d741-4c38-46f3-b681-c3ffb44e54ac",
          "type": "SingleChoice",
          "content": "String in standard library has more functionalities coded into it than string slice?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "923d11ba-5c1c-4d48-8101-87ee08e0fa0e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n  ```\n  fn main() {\n    let first_string = \"This is some string \".to_string();\n    let second_string = \"Let's add some Data\";\n\n    let final_string = first_string + &second_string;\n\n    println!(\"First string is: {}\", first_string);   \n    println!(\"Second string is: {}\", second_string);\n\n    println!(\"Finally we have: {}\", final_string);\n  }\n  ```\n",
          "hint": "NoHint",
          "explanation": "Syntatical Error in the code snippet",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Only 1st print statement shows an output",
              "key": "A"
            },
            {
              "content": "Only 1st and 2nd print statement shows an output",
              "key": "B"
            },
            {
              "content": "All the 3 string statements show an output",
              "key": "C"
            },
            {
              "content": "Error occurs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ec5e9c9b-cafa-484e-8feb-51db5a0b7a33",
          "type": "SingleChoice",
          "content": "Which of the following operator is used by string slices to reference?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`&`",
              "key": "A"
            },
            {
              "content": "`%`",
              "key": "B"
            },
            {
              "content": "`#`",
              "key": "C"
            },
            {
              "content": "`*`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d0b24301-eda6-49d7-bf45-88777b13e15f",
          "type": "SingleChoice",
          "content": "Select the incorrect statement from the following",
          "hint": "Nohint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Once you get a string slice from a string, then you cannot really                 modify that String anymore",
              "key": "A"
            },
            {
              "content": "Using slices to work with Strings allows us to add an extra                       security measure.",
              "key": "B"
            },
            {
              "content": "If you attempt to create a string slice in the middle of a                        multibyte character, your program will exit with an error",
              "key": "C"
            },
            {
              "content": "String Slice mutably borrows the String itself",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ef79a0da-3da6-445e-92b5-1d0e17799db6",
          "type": "SingleChoice",
          "content": "What will happen at the runtime if overflow occurs?",
          "hint": "NoHint",
          "explanation": "The memory stack is full and overflows, so a default panic occurs                 and the program crashes",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Panic and crashes the program",
              "key": "A"
            },
            {
              "content": "Garbage values will be output",
              "key": "B"
            },
            {
              "content": "Those values are ignored and the output is as expected",
              "key": "C"
            },
            {
              "content": "Overflow is handled already by rust, so it doesn’t occur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b152ab5-6524-49e0-b5c0-8bd5153b1ab1",
          "type": "SingleChoice",
          "content": "Character literals are specified using double quotes, as opposed to single quotes which stand for string literals.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "strings",
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "b49785fb-dd24-43b5-9f5a-e7dedc98cc5f",
          "type": "SingleChoice",
          "content": "Strings size is not known at compile time",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "504040ac-6167-4304-8d6e-1e559975bac5",
          "type": "SingleChoice",
          "content": "For the following code\n ```  \n   fn main() {\n     let mut x = 2.0;\n     x: i32= 3.0; \n   }\n ```\n",
          "hint": "type declaration",
          "explanation": "i32 is intialized as a float data type",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The code compiles without errors",
              "key": "A"
            },
            {
              "content": "The code has errors because of immutability",
              "key": "B"
            },
            {
              "content": "The code has errors because of illegal type conversion",
              "key": "C"
            },
            {
              "content": "The code has errors because of no print and return statements",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0ef2f16-b79d-433a-af54-dc218060ef13",
          "type": "SingleChoice",
          "content": "If you want to store boolean values with the provision of adding more             values at runtime, the most suitable way would be to use",
          "hint": "Statically and Dynamic in nature",
          "explanation": "Vector is a Dynamic nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays",
              "key": "A"
            },
            {
              "content": "Tuples",
              "key": "B"
            },
            {
              "content": "Vectors",
              "key": "C"
            },
            {
              "content": "bool type Variables",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c731455f-5296-4b1f-9aee-46a4f77c25c1",
          "type": "SingleChoice",
          "content": "BOOLEAN is a type of data type that basically gives a tautology or                fallacy.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "f8497eb4-2e55-4e70-98c9-b395f254f412",
          "type": "SingleChoice",
          "content": "What are the categories in which keywords are divided in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Weak",
              "key": "A"
            },
            {
              "content": "Strict",
              "key": "B"
            },
            {
              "content": "Reserved",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "836ae5f7-8e1d-41ad-a0b9-e0ce810cbf93",
          "type": "SingleChoice",
          "content": "Which of the following can be used as a variable name in rust?",
          "hint": "NoHint",
          "explanation": "Rest are keywords in rust",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables",
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "crate",
              "key": "A"
            },
            {
              "content": "match",
              "key": "B"
            },
            {
              "content": "await",
              "key": "C"
            },
            {
              "content": "tuple",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "853bbf17-ceb6-4a7c-9a32-c05f048a9ce6",
          "type": "SingleChoice",
          "content": "Identify the wrong set of rust keywords",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "async, await, where, use",
              "key": "A"
            },
            {
              "content": "Move, return, mut, while",
              "key": "B"
            },
            {
              "content": "union, dyn, try, abstract",
              "key": "C"
            },
            {
              "content": "become, box, do, incur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "118287fb-f962-4c6a-b7bb-f774e36f02bf",
          "type": "SingleChoice",
          "content": "Rust variable names can start with",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Letter, underscore",
              "key": "A"
            },
            {
              "content": "Letter, digits",
              "key": "B"
            },
            {
              "content": "Underscore, digits",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6ffbcd01-5b77-44bd-a9e1-56d3adb81a61",
          "type": "SingleChoice",
          "content": "q What is the result of the following calculation in rust \"1.0/0.0\"\n",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A positive number",
              "key": "A"
            },
            {
              "content": "A negative number",
              "key": "B"
            },
            {
              "content": "An unsigned number",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e8c7d69e-3899-43aa-aaec-e45870a32a3f",
          "type": "SingleChoice",
          "content": "In Rust, every value has its data type. The data type tells the compiler what kind of value it is and how to use it.",
          "hint": "noHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "699f89a5-4c2a-4442-afe7-eabc1fb8f5fa",
          "title": "Introduction to Blockchain Technology",
          "shortTitle": "Intro Blockchain",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=u70_rafPs-0",
          "subTopics": [
            "variables"
          ],
          "details": "This video explains about\n* Point 1\n* Point 2\n"
        }
      ],
      "summaries": [
        {
          "title": "Typed language",
          "shortTitle": "Typed language",
          "key": "typed_language",
          "details": "- Dynamically-Typed Languages\n  * Dynamically-typed languages are the languages where the interpreter assigns variables a data type at runtime based on the variable's value at that time.\n  * Dynamic languages are usually interpreted (with some pre-processing for optimisation) so it is fast to make changes and then immediately run the updated program.\n  * Dynamically-Typed languages allows for Fast Development Cycles and Fast Start-up times.\n  * Some Examples of Dynamically Typed Languages are:- JavaScript, Python, Perl, Ruby, etc.\n- Statically-Typed Languages\n  * Statically-typed languages are the languages where variable types are known at compile time i.e. the type checking is done at compile time.\n  * Many runtime errors become compile time errors as the compiler ensures that you are writing 'correct' code. This leads to a much smoother development experience.\n  * The execution of the code will be faster compared to the dynamically-typed languages.\n  * The compiler can use the type system to provide language features that are more expressive and succinct.\n  * Some examples of Statically-Typed Languages are:- C++, Rust, C, Java, etc.\n- Rust is a Statically-Typed Language\n"
        },
        {
          "title": "Value Types",
          "shortTitle": "Value Types",
          "key": "value-types",
          "details": "- Rust has two major Data Value Types, which include \n    1. Scalar Types\n    2. Compound ypes\n- Scalar Types\n  * A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.\n  - Integers\n    * An integer is a number without a fractional component.\n    * An integer can be of the following sizes:- 8-bit, 16-bit, 32-bit, 64-bit, 128-bit, arch.\n    * Integers can be either signed or unsigned. Signed and unsigned refer to whether it’s possible for the number to be negative—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned).\n    * Integers can be declared using keyword let, and explicitly defining the variable size and it's type of signed or unsigned integer.\n    * For example, we can declare a 64-bit signed and 32-bit unsigned integer in the following ways respectively :- \n    ```\n        1. let mut x: i64 = -20;\n        2. let mut x: u32 = 20;\n    ```\n    * The isize and usize types depend on the architecture of your build, which is denoted in the table as “arch”: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit architecture.\n    * The number literals that can be multiple numeric types allow a type suffix, such as `20u32`, to designate the type. Number literals can also use `_` as a visual separator to make the number easier to read, such as `1_000` , which will have the same value as if you had specified `1000`.\n    - Integer Overflow\n      * Let's say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, integer overflow will occur, which can result in one of two behaviors:- \n        1. When you're compiling in `debug` mode, Rust includes checks for integer overflow that cause your program to panic at runtime if this behavior occurs.\n        2. When you're compiling in release mode with the `--release` flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping.\n  - Floating-Point Types\n    * Floating-Point Types are number with the decimal points.\n    * Floating-point types are f32 and f64, which are 32 bits and 64 bits in size, respectively.\n    * All the Floating-Point Types are signed.\n    * The default Floating-Point Type is of 64-bit.\n    * The `f32` type is a single-precision float, and `f64` has double precision.\n    * We can declare a float type variable in the following ways:- \n     ```\n        fn main() {\n              let x = 2.0; // f64\n              let y: f32 = 3.0; // f32\n        }\n      ```\n  - Boolean Type\n    * There are two possible constant values:- True & False.\n    * Booleans are one byte in size.\n    * They are declared using the keyword 'bool'.\n  - Character Type\n    * Character Data Type doesn't use ASCII values like other programming languages but uses Unicode Scalar Value.\n    * It uses 4 bytes i.e. 32 bits of space for each character rather than 1 byte because of Unicode Scalar Values.\n    * We can use many more types of characters in rust, like, Chinese, emojis, etc.\n- Compound Data Types\n  * Compound types can group multiple values into one type. The two primitive compound types in rust are: Tuples and Arrays.\n  - Tuples\n    * A tuple is a general way of grouping together a number of values with a variety of types into one compound type.\n    * Tuples have a fixed length: once declared, they cannot grow or shrink in size.\n    * Tuples are created by a comma seperated List.\n    * Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same.\n    * For Example:- \n      ```\n        fn main() {\n          let tup: (i32, f64, u8) = (500, 6.4, 1);\n        }\n      ```\n    * We can access a tuple element directly by using a period `(.)` followed by the index of the value we want to access\n    * The tuple without any values has a special name knows as \"unit\".\n    * \"unit's\" value and its corresponding type are both written () and represent an empty value or an empty return type. \n    * Expressions implicitly return the unit value if they don’t return any other value. \n  - Arrays\n    * Arrays are a collection of multiple values, stored in a single entity.\n    * Unlike a tuple, every element of an array must have the same data type.\n    * Arrays in Rust have a fixed length, i.e. they are not dynamic in nature by default.\n    * Arrays are useful when you want your data allocated on the stack rather than the memory heap.\n    * For Example:- \n      ```\n        fn main() {\n            let a: [i32; 5] = [1, 2, 3, 4, 5];\n        }\n      ```\n      Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.\n    *  We can access elements of an array using indexing, like this:\n      ```\n        fn main() {\n            let a = [1, 2, 3, 4, 5];\n        \n            let first = a[0]; // outputs 1\n            let second = a[1]; // outputs 2\n        }\n      ```\n"
        },
        {
          "title": "Variables",
          "shortTitle": "Variables",
          "key": "variables",
          "details": "- Variables are used to store the values of a particular data type\n- Variables and Mutability\n  * In Rust, variables are immutable in nature by default.\n  * When a variable is immutable, once a value is bound to a name, you can’t change that value\n  * To make the variables mutable, we use the keyword:- `mut`.\n  * For Example:-\n    ```\n      fn main() {\n          let mut x = 5;\n          println!(\"The value of x is: {x}\");\n          x = 6;\n          println!(\"The value of x is: {x}\");\n      }\n    ```\n- Constants\n  * Constants are values that are bound to a name and are not allowed to change, i.e. they are also immutable.\n  * Usage of keyword `mut` isn't allowed with constants.\n  * Constants are immutable by default, and also they’re always immutable.\n  * We declare constants using the `const` keyword instead of the `let` keyword, and the type of the value must be annotated.\n  * Constants can be declared in any scope, including the global scope, making them useful for values that many parts of code need to know about.\n  * Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.\n  * For Example:-\n    ```\n      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n    ```\n"
        },
        {
          "title": "Keywords",
          "shortTitle": "Keywords",
          "key": "keywords",
          "details": "- Keywords are predefined, reserved words used in programming that have special meanings to the compiler. Rust divides keywords into three categories:\n    1. Strict\n    2. Reserved \n    3. Weak\n- Strict Keywords\n  * These keywords can only be used in their correct contexts. They cannot be used as the names of: Items, Variables and function parameters, etc.\n  * For Example:- ` mut, break, else, continue, return, impl, etc. ` \n- Reserved Variables\n  * These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords.\n  * For Example:- ` abstract, try, do, final, typeof, etc. `\n- Weak Keywords\n  * These keywords have special meaning only in certain contexts.\n  * For example, it is possible to declare a variable or method with the name `union`.\n"
        },
        {
          "title": "Bit Manipulation",
          "shortTitle": "Bit Manipulation",
          "key": "bit-manupilation",
          "details": "- Bit manipulation is the process of applying logical operations on a sequence of bits to achieve a required result.\n- Bit Mnipulation is strictly done by rust compilers for storing data in variables, for two's compliment and many other purposes.\n"
        },
        {
          "title": "Strings",
          "shortTitle": "Strings",
          "key": "strings",
          "details": "- There are two types of strings in Rust: `String` and `&str`.\n- String\n  * Strings are formed by a list of characters, which is really an \"array of characters\".\n  * A String is stored as a vector of bytes `(Vec<u8>)`.\n  * A String is made up of three components: a pointer to some bytes, a length, and a capacity.\n  * The pointer points to an internal buffer String uses to store its data.\n  * The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.\n  * The buffer is always stored on the heap.\n  * It is guaranteed to always be a valid `UTF-8` sequence. \n  * String is heap allocated, growable and not null terminated.\n  * We can create a String from a literal string with `String::from`\n  * We can append a char to a String with the push method, and append a &str with the `push_str` method\n- &str\n  * The str type, also called a 'string slice', is the most primitive string type.\n  * A &str is made up of two components: a pointer to some bytes, and a length.\n  * `&str` is `(&[u8])` that always points to a valid UTF-8 sequence.\n  * It can be used to view into a String, just like `&[T]` is a view into `Vec<T>`.\n"
        },
        {
          "title": "Package Manager",
          "shortTitle": "Package Manager",
          "key": "package-manager",
          "details": "- A package manager or package-management system is a collection of software tools that automates the process of installing, upgrading, configuring, and removing computer programs for a computer in a consistent manner.\n- Cargo is the Rust package manager.\n"
        }
      ]
    },
    {
      "title": "Control Flow & Functions",
      "key": "control-flow-functions",
      "details": "This chapter talks in-depth about the conditional statements, for and while loops, functions in rust, and Error handling.\n - Conditional Statements\n    1. If-Else statements\n    2. Nested If-Else, nested If statements\n    3. Match, pattern matching\n - Loops\n    1. For Loops\n      a. Nested for loops, range-based for loops\n    2. While Loops\n - Functions\n    1. Parameters, Statements\n    2. Functions with Return Values\n - Error Handling\n    1. Recoverable Errors\n      a. Option\n      b. Result\n    2. Combinators\n      a. Using combinators on Options and Results\n      b. Conversion between Options and Results\n    3. Early Returns and \"?\" operator\n    4. Non-recoverable errors\n      a. Panics\n    5. Custom Errors\n",
      "order": 2,
      "questions": [
        {
          "uuid": "0111a385-b650-4db6-a8ae-434b6d26c36e",
          "type": "SingleChoice",
          "content": "________ is a method that allows you to, instead of handling possible errors inside the current function you're writing, to pass the error up to the caller of this function and handle the error there.\n",
          "hint": "Error handling",
          "explanation": "it returns a Return to whoever is calling the function to handle it.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "error-handling"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Unwrap and Expect",
              "key": "A"
            },
            {
              "content": "Result<T,E>",
              "key": "B"
            },
            {
              "content": "Panic!",
              "key": "C"
            },
            {
              "content": "Error Propagating",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9dfe3dbe-2f14-4541-8b8f-78441eaa904c",
          "type": "SingleChoice",
          "content": "If the error is of the unrecoverable nature, the _____ macro is executed\n",
          "hint": "Error handling",
          "explanation": "prints an error message to the screen then unwinds",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "error-handling"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Not to panic",
              "key": "A"
            },
            {
              "content": "Result<T,E>",
              "key": "B"
            },
            {
              "content": "Panic!",
              "key": "C"
            },
            {
              "content": "Error P?",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "35fe5c1c-58a1-4921-9ff2-ea5ca4c21708",
          "type": "SingleChoice",
          "content": "Rust splits errors into 2 categories, Recoverable errors and\n",
          "hint": "Error handling",
          "explanation": "type of errors",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "error-handling"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Not important errors",
              "key": "A"
            },
            {
              "content": "Non-Recoverable errors",
              "key": "B"
            },
            {
              "content": "Immediate errors",
              "key": "C"
            },
            {
              "content": "Data Errors",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "372ec2d3-b8cb-48a2-b9a2-e15628cc89b6",
          "type": "SingleChoice",
          "content": "An 'if' expression is a ________ branch in program control.\n",
          "hint": "if statement",
          "explanation": "A statement that gets checked",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "control-flow"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Match",
              "key": "A"
            },
            {
              "content": "Method",
              "key": "B"
            },
            {
              "content": "Condition",
              "key": "C"
            },
            {
              "content": "Office",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a48ba4aa-ea0f-4e7e-b040-95d720ea2d72",
          "type": "SingleChoice",
          "content": "The condition operands must have the _______ type.\n",
          "hint": "A data type",
          "explanation": "The condition must be 0 or 1",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "if-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "String",
              "key": "A"
            },
            {
              "content": "Boolean",
              "key": "B"
            },
            {
              "content": "Integer",
              "key": "C"
            },
            {
              "content": "Float",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8600c9e3-5095-441d-856f-a36e9efcc278",
          "type": "SingleChoice",
          "content": "What is the output?\n```rust\n    fn main() {\n      let number = 8;\n\n      if number < 9 {\n        println!(\"condition was true\");\n      } else {\n        println!(\"condition was false\");\n      }\n    }\n```\n",
          "hint": "If else",
          "explanation": "The condition of 8 being lesser than 9 is correct",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "if-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "condition was false",
              "key": "A"
            },
            {
              "content": "number = 8",
              "key": "B"
            },
            {
              "content": "Throws error",
              "key": "C"
            },
            {
              "content": "condition was true",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6f2dcef1-b20b-4e02-b2bd-ee0f03ef298d",
          "type": "SingleChoice",
          "content": "What will be the output if we run this code section?\n```rust\n  fn main() {\n    let number = 3;\n\n    if number {\n      println!(\"number was three\");\n    }\n  }\n```\n",
          "hint": "Data type",
          "explanation": "should be a condition",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "if-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "3",
              "key": "A"
            },
            {
              "content": "True",
              "key": "B"
            },
            {
              "content": "error[E0308]: mismatched types",
              "key": "C"
            },
            {
              "content": "number is 3",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "061c992d-0a9f-4283-b82c-ef340ad4b566",
          "type": "SingleChoice",
          "content": "What is the output?\n```rust\n  fn main() {\n    let digit = 34;\n    if digit != 0 {\n      println!(\"number was something other than zero\");\n    }\n  }\n```\n",
          "hint": "Take note of the !=",
          "explanation": "!= is not equal to, so if the digit is not equal to zero, do the next statement",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "if-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Mismatched type",
              "key": "A"
            },
            {
              "content": "digit error",
              "key": "B"
            },
            {
              "content": "False",
              "key": "C"
            },
            {
              "content": "number was something other than zero",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "bb41cdea-73a2-491c-ae08-70002ac30fa2",
          "type": "SingleChoice",
          "content": "____ often useful to execute a block of code more than once.\n",
          "hint": "iteration",
          "explanation": "more than one execution",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Loop",
              "key": "A"
            },
            {
              "content": "Function",
              "key": "B"
            },
            {
              "content": "Result",
              "key": "C"
            },
            {
              "content": "Print",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7621c8d3-0d2d-4237-921d-988824ef2736",
          "type": "SingleChoice",
          "content": "The loop keyword tells Rust to execute a block of code over until you explicitly tell it to stop.\n What happens if you don't tell it to stop?\n",
          "hint": "Looping out",
          "explanation": "loop are forever",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "it stop by itself",
              "key": "A"
            },
            {
              "content": "It slow down",
              "key": "B"
            },
            {
              "content": "It loops forever",
              "key": "C"
            },
            {
              "content": " ask you to stop it",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "23291951-39c9-4dcf-9788-ce9dff03bed4",
          "type": "SingleChoice",
          "content": "What will happen if we run this code?\n```rust\n  fn main() {\n    loop {\n      println!(\"again!\");\n    }\n  } \n```\n",
          "hint": "Looping",
          "explanation": "it just loop forever",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It prints again forever till you kill the terminal",
              "key": "A"
            },
            {
              "content": "it stops after 100 times",
              "key": "B"
            },
            {
              "content": "Error: couldn't run: no end",
              "key": "C"
            },
            {
              "content": "It end immediately",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2fc1b82f-e876-4a3f-a6e2-68798ce7888c",
          "type": "SingleChoice",
          "content": "What is the value of result?\n```rust\n  fn main() {\n    let mut counter = 0;\n\n    let result = loop {\n      counter += 1;\n\n      if counter == 10 {\n        break counter * 3;\n      }\n    };\n\n    println!(\"The result is {result}\");\n  }\n```\n",
          "hint": " watch the declaration of result",
          "explanation": "",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "if-else-let-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "100",
              "key": "A"
            },
            {
              "content": "20",
              "key": "B"
            },
            {
              "content": "30",
              "key": "C"
            },
            {
              "content": "40",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8f76e7b0-db4c-492e-8726-cd2cbd1a18c7",
          "type": "SingleChoice",
          "content": "A program will often need to evaluate a condition within a loop. What keywords is best at checking the condition?\n",
          "hint": "breaking loop",
          "explanation": "",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "for-loop-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "For and While",
              "key": "A"
            },
            {
              "content": "If and Panic",
              "key": "B"
            },
            {
              "content": "panic and println",
              "key": "C"
            },
            {
              "content": "for and if",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "97e6a555-4053-432b-ba11-ec6eff3aa491",
          "type": "SingleChoice",
          "content": "What is the output of this?\n```rust\n  fn main() {\n    let mut number = 3;\n    while number != 0 {\n      println!(\"{number}!\");\n      number -= 1;\n    }\n    println!(\"LIFTOFF!!!\");\n  }\n```\n",
          "hint": "Loop while number is not zero yet",
          "explanation": "we looped from 3 down 0 and broke out",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "3! 2! 1! LIFTOFF!!!",
              "key": "A"
            },
            {
              "content": "1! 2! LIFTOFF!!!",
              "key": "B"
            },
            {
              "content": "error",
              "key": "C"
            },
            {
              "content": "LIFTOFF!!!",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "531159db-111c-423b-9acd-5a6586febccf",
          "type": "SingleChoice",
          "content": "Complete the sentence.\nThe safety and conciseness of _____ make them the most commonly used loop construct in Rust.\n",
          "hint": "A loop statement",
          "explanation": "",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "While loop",
              "key": "A"
            },
            {
              "content": "If-else",
              "key": "B"
            },
            {
              "content": "For loop",
              "key": "C"
            },
            {
              "content": "While for",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7f76a44b-5a88-4823-80f9-26ea8bd266f6",
          "type": "SingleChoice",
          "content": "The ____ function(most important function), which is the entry point of many programs.\n",
          "hint": "Function",
          "explanation": "it is the functions of all function",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Branch",
              "key": "A"
            },
            {
              "content": "Sub",
              "key": "B"
            },
            {
              "content": "VIP",
              "key": "C"
            },
            {
              "content": "main",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1ff53709-57e9-4560-9406-89a3e3f01a9c",
          "type": "SingleChoice",
          "content": "Rust code uses snake case as the conventional style for _______ and variable names\n",
          "hint": "Function naming convention",
          "explanation": "letters are lowercase and underscores separate words",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Parameter",
              "key": "A"
            },
            {
              "content": "Function",
              "key": "B"
            },
            {
              "content": "File",
              "key": "C"
            },
            {
              "content": "Object",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9a777f39-db37-4840-9286-14fbc43a4385",
          "type": "SingleChoice",
          "content": "We define a function in Rust by entering ____ followed by a function name and a set of parentheses.\n",
          "hint": "Declaring a function",
          "explanation": "Thats the Rust keyword",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Sn",
              "key": "A"
            },
            {
              "content": "func",
              "key": "B"
            },
            {
              "content": "fn",
              "key": "C"
            },
            {
              "content": "function",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "49b77d7b-8230-4d9d-ac53-6eea65859b37",
          "type": "SingleChoice",
          "content": "What is the output?\n```rust\n   fn main() {\n     println!(\"Hello, my name is John.\");\n\n     another_function();\n   }\n\n   fn another_function() {\n      println!(\"Another function.\");\n   }\n```\n",
          "hint": "Function calling",
          "explanation": "You call function in the main for this example",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Hello, my name is John. Another function",
              "key": "A"
            },
            {
              "content": "Another function",
              "key": "B"
            },
            {
              "content": "Hello, my name is John.",
              "key": "C"
            },
            {
              "content": " Another function Hello, my name is John.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b4d11d66-dcd6-4e7e-aa09-8e2d40d1763d",
          "type": "SingleChoice",
          "content": "The ___ brackets tell the compiler where the function body begins and ends.\n",
          "hint": "function delaration",
          "explanation": "Declaring every function in a block",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Curly",
              "key": "A"
            },
            {
              "content": "Square",
              "key": "B"
            },
            {
              "content": "Angle",
              "key": "C"
            },
            {
              "content": "Parentheses",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "66b285ee-16ea-4dc5-9ebf-a71b2f8115b4",
          "type": "SingleChoice",
          "content": "What is the output?\n ```rust\n    fn main() {\n      let x = 7;\n      if x == 5 {\n        println!(\"x is five!\");\n      } else if x == 6 {\n        println!(\"x is six!\");\n      } else {\n        println!(\"x is not five or six :(\");\n      }\n    }\n ```\n",
          "hint": "Nested if-else statement",
          "explanation": "Find the correct condition",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "nested-if-else-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "x is five!",
              "key": "A"
            },
            {
              "content": "x is not five or six :(",
              "key": "B"
            },
            {
              "content": "x is six!",
              "key": "C"
            },
            {
              "content": "x is seven!",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "23c0f874-10dc-4e32-bd16-fe17a9a5fbad",
          "type": "SingleChoice",
          "content": "The ____ operator can only be used in functions whose return type is compatible with the value the ? is used on\n",
          "hint": "error handling operator",
          "explanation": "if it is not compatiable it would not work",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "error-handling"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "?",
              "key": "A"
            },
            {
              "content": "::",
              "key": "B"
            },
            {
              "content": "<T,E>",
              "key": "C"
            },
            {
              "content": "//",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5b135105-a416-42f5-965b-76fb9fce5852",
          "type": "SingleChoice",
          "content": "What will happen if we run this code?\n```rust\n  fn main() {\n     panic!(\"crash and burn\");\n  }\n ```\n",
          "hint": "Panic first",
          "explanation": "it is not a print function",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "error-handling"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "timeout error",
              "key": "A"
            },
            {
              "content": "fails to compile",
              "key": "B"
            },
            {
              "content": "it panic at crash and burn",
              "key": "C"
            },
            {
              "content": "print out crash and burn",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "084c634a-f438-4ff0-a906-b554018ef18d",
          "type": "SingleChoice",
          "content": "What is a Statement?\n",
          "hint": "Statement",
          "explanation": "instructions only, doesn't do any other thing",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statements are instructions that perform some action and do not return a value",
              "key": "A"
            },
            {
              "content": "Statement are a library function",
              "key": "B"
            },
            {
              "content": "statements are the core of a program",
              "key": "C"
            },
            {
              "content": "Statements are instructions that perform some action and return a value",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c5df8ee5-f8ed-439b-ab10-605e6b394661",
          "type": "SingleChoice",
          "content": "Complete the sentence\nFunction bodies are made up of a series of ______ optionally ending in an ______\n",
          "hint": "function body",
          "explanation": "They make up a function",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement and methods",
              "key": "A"
            },
            {
              "content": "Statement and expression",
              "key": "B"
            },
            {
              "content": "Expression and methods",
              "key": "C"
            },
            {
              "content": "Expression and Statement",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "93d9080c-f484-43ac-ba71-3670a2500a7f",
          "type": "SingleChoice",
          "content": "What part of your code can be evaluate to a resulting value.\n",
          "hint": "Function body",
          "explanation": " They are calculated ",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement",
              "key": "A"
            },
            {
              "content": "Function",
              "key": "B"
            },
            {
              "content": "Expression",
              "key": "C"
            },
            {
              "content": "Methods",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6b5885d2-91cc-4979-b731-7c1a2e9a907a",
          "type": "SingleChoice",
          "content": "What fragment of code is an expression here?\n```rust\n  fn main() {\n    let y = {\n      let x = 3;\n      x + 1\n    };\n\n    println!(\"The value of y is: {y}\");\n  }\n```\n",
          "hint": "not a statement",
          "explanation": "it should be a computation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "{ let x = 3; = x + 1 }",
              "key": "A"
            },
            {
              "content": "let x = 3",
              "key": "B"
            },
            {
              "content": "println!(The value of y is: {y});",
              "key": "C"
            },
            {
              "content": "fn main() ",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f24f175d-7a12-45b8-8f95-b85f6381540e",
          "type": "SingleChoice",
          "content": "Which is not a control flow method?\n",
          "hint": "which can be use for iteration",
          "explanation": "the odd one is use for error handling",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "for-loop",
              "key": "A"
            },
            {
              "content": "if-else",
              "key": "B"
            },
            {
              "content": "while-loop",
              "key": "C"
            },
            {
              "content": "panic!",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d18f8f03-0600-46b5-9fc3-70aecb555379",
          "type": "SingleChoice",
          "content": "Can a loop be inside a loop?\n",
          "hint": "Nested loops",
          "explanation": "you can break and continue with loops",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "only when you use the Panic! method",
              "key": "A"
            },
            {
              "content": "No",
              "key": "B"
            },
            {
              "content": "Yes, we break and can continue",
              "key": "C"
            },
            {
              "content": "Loop are statement",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d8e164a6-a3ee-4dd6-a07f-4381fdb5b8c0",
          "type": "SingleChoice",
          "content": "Functions can return _____ to the code that calls them\n",
          "hint": "returns something important",
          "explanation": "functions have to be called",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Values",
              "key": "A"
            },
            {
              "content": "function",
              "key": "B"
            },
            {
              "content": "statement",
              "key": "C"
            },
            {
              "content": "numbers",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "95077da8-24ad-4ddf-bc75-9a0387349f62",
          "type": "SingleChoice",
          "content": "Take a look at this little complex code, what best decribe the output?\n```rust\n     fn main() {\n       // `n` will take the values: 1, 2, ..., 100 in each iteration\n        for n in 1..101 {\n          if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n          } else if n % 3 == 0 {\n            println!(\"fizz\");\n          } else if n % 5 == 0 {\n            println!(\"buzz\");\n          } else {\n            println!(\"{}\", n);\n          }\n       }\n     }\n   ```\n",
          "hint": "division without reminder",
          "explanation": "from 1 to 101, if the remainder matches a condition it prints its output",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "nested-if-else-statement"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "it fails completely",
              "key": "A"
            },
            {
              "content": "it prints from 1 to 101",
              "key": "B"
            },
            {
              "content": "It moves from 1 to 101, and test each number against the condition and prints out the first condition output it matches",
              "key": "C"
            },
            {
              "content": "The code ends because nested if statement needs break command",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "aabc6ca8-307d-4b5e-bbc2-ac8e46a8fb83",
          "type": "SingleChoice",
          "content": "What is the output?\n  ```rust\n    fn main( ) {\n      let strn = \"DoDAOCourse\";\n      let fixed_string = \"DDC\";\n      if fixed_string == strn {\n        println!(\"Same\");\n      } else {\n        println!(\"Not Same\");\n \t  }\n    }   \n ```\n",
          "hint": " Data comparision",
          "explanation": "We use if and let statement to compare the strings",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "looping-value"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Same",
              "key": "A"
            },
            {
              "content": "Not Same",
              "key": "B"
            },
            {
              "content": "Error: let is not a keyword",
              "key": "C"
            },
            {
              "content": "DoDAOCourse",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2a9e9798-a646-4021-8469-6f889ced1e08",
          "type": "SingleChoice",
          "content": "What is the output?\n```rust\n  fn main() {  \n    n = 7;\n    if n>10 { \n      println!(\"Greater than 10\");\n    } else {\n      println!(\"Smaller than 10\");\n    }\n  }\n```\n",
          "hint": "greater than or less than",
          "explanation": " its simple enough",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "if-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Smaller than 10",
              "key": "A"
            },
            {
              "content": "Smaller than 7",
              "key": "B"
            },
            {
              "content": "Greater than 10",
              "key": "C"
            },
            {
              "content": "Greater than 7",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f0cf97a2-753e-4ec3-8648-3a8205582580",
          "type": "SingleChoice",
          "content": "What is the output?\n```rust\n  fn main() {\n    let n = 9;\n    if n>10 {\n      println!(\"Greater than 10\");\n    } else if n==10 {\n      println!(\"Equal to 10\"); \n    } else { \n      println!(\"Smaller than 10\");\n    }   \n  }\n```\n",
          "hint": "Find the conditions that matches",
          "explanation": "Iterate and find the mathematical solution",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "if-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Equal to 10",
              "key": "A"
            },
            {
              "content": "Greater than 10",
              "key": "B"
            },
            {
              "content": "Greater than 9",
              "key": "C"
            },
            {
              "content": "Smaller than 10",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f309a64f-591d-4b23-8c86-d5947fc5254b",
          "type": "SingleChoice",
          "content": "What is the output?\n```rust\n  use std::fs::File;\n\n  fn main() {\n    let f = File::open(\"gfg.txt\");\n    println!(\"{:?}\",f);\n  }\n ```\n",
          "hint": "Result error method",
          "explanation": "file gfg.txt was not there",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "result-option"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Err(Os { code: 2, kind: NotFound, message: 'No such file or directory' })",
              "key": "A"
            },
            {
              "content": "thread 'main' panicked at 'index out of bounds:",
              "key": "B"
            },
            {
              "content": "Null error",
              "key": "C"
            },
            {
              "content": "File has been opened",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "be2c74c0-de24-4808-8db7-25335f97e5de",
          "type": "SingleChoice",
          "content": "What is the expected output?\n```rust\n  use std::fs::File;\n  fn main() {\n    // file doesn't exist\n    let f = File::open(\"gfg.txt\");\n    match f {\n \t  Ok(file) => {\t\n        println!(\"file found {:?}\",file);\n \t  },\n      Err(_error) => {\n        // replace it with whatever you want\n        // to do if file is not found\n        println!(\"file not found \\n\"); \n      }\n    }\n  }\n```\n",
          "hint": "Result error when missing an item",
          "explanation": "matches the return type of the result",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "result-option"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "file found ",
              "key": "A"
            },
            {
              "content": "file not found ",
              "key": "B"
            },
            {
              "content": "Err(Os { code: 2, kind: NotFound, message: 'No such file or directory' })",
              "key": "C"
            },
            {
              "content": "Opened file",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8b82af20-1400-404d-9012-8561ebb6be27",
          "type": "SingleChoice",
          "content": "What is the output of this code?\n```rust\n  fn main() {\n    let result = eligible(13);\n    match result {\n      Ok(age) => {\n        println!(\"Person eligible to vote with age={}\", age);\n      }\n      Err(msg) => {\n        println!(\"{}\", msg);\n      }\n    }\n  }\n  fn eligible(age: i32) -> Result<i32, String> {\n    if age >= 18 {\n      return Ok(age);\n    } else {\n      return Err(\"Not Eligible..Wait for some years\".to_string());\n    }\n  }\n```\n",
          "hint": "Compare the age give to the required voting age",
          "explanation": "to produce an error if a person below 18 years tries to apply for voter ID",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "result-option"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "Not Eligible..Wait for some years",
              "key": "A"
            },
            {
              "content": "Person eligible to vote with 13 years",
              "key": "B"
            },
            {
              "content": "Error: Panicked at Err",
              "key": "C"
            },
            {
              "content": "Failed to compile",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ded49462-cbf9-422e-9d82-747586e59081",
          "type": "SingleChoice",
          "content": "Describe the output(best fit) \n  ```rust\n    fn main() {\n      let mut n = 10;\n      while n != 0 {\n        println!(\"{}\", n);\n        n -= 1;\n      }\n    }\n  ```\n",
          "hint": "loop from 10 down",
          "explanation": "Counting from 10 to 1 ",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Count up from 1 to 10",
              "key": "A"
            },
            {
              "content": "Print from 1 to 10",
              "key": "B"
            },
            {
              "content": "Print out from 10 to 1",
              "key": "C"
            },
            {
              "content": "Count down from 10 to 1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "17f6d7a9-a512-477d-af2e-14cfedc74657",
          "type": "SingleChoice",
          "content": "hat is the output?\n```rust\n  fn main() {\n    let mut n = 1;\n    while n <= 5 {\n      println!(\"{}\", n * 2);\n      n += 1;\n    }\n  }\n```\n",
          "hint": "multiply by 2, and count to 5",
          "explanation": "while n is less or requal than 5 do something",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "loop"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "2 4 6 8 10",
              "key": "A"
            },
            {
              "content": "1 2 3 4 5",
              "key": "B"
            },
            {
              "content": "1 3 6 9 11",
              "key": "C"
            },
            {
              "content": "2 5 ",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3723f90d-ce8a-47cb-809f-c4676150fc4b",
          "type": "SingleChoice",
          "content": "Arguments are passed after function name inside ______\n",
          "hint": "Function parameter",
          "explanation": "very important we put args in a bracket",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "arguments"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "parenthesis",
              "key": "A"
            },
            {
              "content": "Curtly bracket",
              "key": "B"
            },
            {
              "content": "square bracket",
              "key": "C"
            },
            {
              "content": "Block bracket",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "802a45f7-6356-4e0e-8abb-12f1da27b68e",
          "type": "SingleChoice",
          "content": "What does the greet function take as argument?\n```rust\n    fn main() {\n      greet(\"kushwanthreddy\");\n    }\n    fn greet(name: &str) {\n       println!(\"hello {} welcome to geeksforgeeks\", name);\n    }\n```\n",
          "hint": "The greet function has name args",
          "explanation": "look at the parenthesis",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "arguments"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "name(string)",
              "key": "A"
            },
            {
              "content": "kushwanthreddy",
              "key": "B"
            },
            {
              "content": "name(integer)",
              "key": "C"
            },
            {
              "content": "name(boolean)",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "63990083-058f-4bfc-83ca-146c35e725f7",
          "type": "SingleChoice",
          "content": "When a semi-colon is written at the end of an expression, it turns into a ____?\n",
          "hint": "part of a function",
          "explanation": "no explantion needed",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Values",
              "key": "A"
            },
            {
              "content": "Statement",
              "key": "B"
            },
            {
              "content": "function",
              "key": "C"
            },
            {
              "content": "Parameter",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2c30a2c4-7a4f-46a7-b460-7216f3ac5b15",
          "type": "SingleChoice",
          "content": "What are the arguments passed in the code below?\n```rust\n\tfn main() {\n      print_sum(5, 6);\n    }\n   \tfn print_sum(x: i32, y: i32) {\n       println!(\"sum is: {}\", x + y);\n    }\n ```\n",
          "hint": "parenthesis",
          "explanation": "we pass args inside a bracket to call them",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "arguments"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "x: i32, y: i32",
              "key": "A"
            },
            {
              "content": "x: , y:",
              "key": "B"
            },
            {
              "content": "32, y: i32",
              "key": "C"
            },
            {
              "content": "5, 6",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "21c66e14-e027-4956-8571-00605eb93c1c",
          "type": "SingleChoice",
          "content": "How can a function be called?\n",
          "hint": "noHint",
          "explanation": "We call function by its name and arguments",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "function_name(argument)",
              "key": "A"
            },
            {
              "content": "call function_name(main)",
              "key": "B"
            },
            {
              "content": "let = function_name(main)",
              "key": "C"
            },
            {
              "content": "function_name(main)::called",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "43421be6-7aa1-402a-baaa-d3d88bafc987",
          "type": "SingleChoice",
          "content": "What will happen if we run this program?\n```rust\n\tfn main() {\n \t  let number = 5;\n   \t  if number % 2 == 1 {\n        if number % 3 == 0 {\n          println!(\"Odd and divisible by 3\");\n        }\n      }\n    }\n ```\n",
          "hint": "after the first if, follow to the next",
          "explanation": "null",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "it prints : Odd and divisible by 3",
              "key": "A"
            },
            {
              "content": "it print: Odd and divisible by 5",
              "key": "B"
            },
            {
              "content": "Error use one if",
              "key": "C"
            },
            {
              "content": "it prints nothing",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1cac4f25-85c1-4a1f-8daf-9da73252f81b",
          "type": "SingleChoice",
          "content": "We create control flow by using if,for,while statement in combination with ______ and _____\n",
          "hint": "creating flow requires conditions and conditions are statement and reasonings",
          "explanation": "null",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "control-flow"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "relational comparison and logical operator",
              "key": "A"
            },
            {
              "content": "boolean and data type",
              "key": "B"
            },
            {
              "content": "functions and constructor",
              "key": "C"
            },
            {
              "content": "compiler and error",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a56460a0-e567-4970-9e87-0db399dfddbd",
          "type": "SingleChoice",
          "content": "What is the output?\n```rust\n  fn main() {\n    let check_value= 200;\n    if check_value < 100 {\n      println!(\"The decision returns true !\"); \n    } else {\n      println!(\"The decision returns false!\"); \n    } \n  }\n```\n",
          "hint": "check the condition",
          "explanation": "xomparing the number we the the greater one",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "if-else-let-statement"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The decision returns false!",
              "key": "A"
            },
            {
              "content": "The decision returns true!",
              "key": "B"
            },
            {
              "content": "Failed to compile",
              "key": "C"
            },
            {
              "content": "The decision returns indecisive!",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9d45007e-4c06-4b34-b6db-7a4ab848cc7a",
          "type": "SingleChoice",
          "content": "What will happen when will run this?\n```rust\n \tfn main() {\n      let a = [1,2,3];\n      a[4] \n    }\n ```\n",
          "hint": "Error Handling - Panic",
          "explanation": "we trying to call an index of 4 in a array of max:2 index",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "panic-not-panic"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "it prints 4",
              "key": "A"
            },
            {
              "content": "nothing happens",
              "key": "B"
            },
            {
              "content": "Panic! error occurs at:> a[4]",
              "key": "C"
            },
            {
              "content": "it prints the array",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d95e6e00-d6fa-4e0b-8558-e3b8d690d30d",
          "type": "SingleChoice",
          "content": "A function can reduce the number of codes, which saves ____.\n",
          "hint": "Function can be called from different place and we don't have to code them",
          "explanation": "code reusability is important to programmers",
          "difficultyLevel": "Low",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "functions"
          ],
          "choices": [
            {
              "content": "Values",
              "key": "A"
            },
            {
              "content": "Memory",
              "key": "B"
            },
            {
              "content": "Time",
              "key": "C"
            },
            {
              "content": "Money",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "44b73ef1-b860-4ecd-b1b7-c2620817c31e",
          "title": "Control Flow - Rust",
          "shortTitle": "Intro control flow",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=EVruNiwIfzI",
          "subTopics": [
            "if-statement",
            "loop"
          ],
          "details": "In this video we're looking how to write control flow in Rust language.\nThis video explains about the use of -\n* if-else and nested else condition and using if in a let Statement\n* while loop statement and passing conditions while the statement is true\n* for loop and iteration\n"
        },
        {
          "uuid": "49b6d99f-9965-42aa-8115-edf28c7735bb",
          "title": "Rust Lang Tutorial 2021 - Functions",
          "shortTitle": "functions/procedures",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=hSSYwVfzaZM",
          "subTopics": [
            "functions",
            "arguments"
          ],
          "details": "In this video we're looking how to write functions in Rust language.\nThis video talks about the use of -\n* Rust Simple function\n* Rust Function with arguments\n* Rust Function with return\n* Rust Function return with expression (no semi-colon)\n"
        },
        {
          "uuid": "ca11e46b-bcbd-4dd7-bf44-965a64863fb2",
          "title": "Intro to Rust-lang (Error Handling)",
          "shortTitle": "error handing",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=mhw-x5Q_-z0",
          "subTopics": [
            "panic-not-panic",
            "result-option",
            "options"
          ],
          "details": "In this video, we look at how we can use the Result and Option Enums to deal with Errors in Rust. \nWe also look at some of the basic methods that are commonly used in place of pattern match statements to check errors. \n* Error handling using Result options\n* Error handling using Enum options\n* Error handling using ? operations \n* Error handling using Panic!\n"
        },
        {
          "uuid": "140a5c04-73de-4b0e-ab1b-ba85c119b001",
          "title": "Introduction to Control flow",
          "shortTitle": "control flow",
          "type": "Article",
          "url": "https://doc.rust-lang.org/book/ch03-05-control-flow.html#control-flow",
          "subTopics": [
            "control-flow"
          ],
          "details": "In this article we're looking how to write control flow in Rust language.\nThis article explains about the use of -\n* if-else and nested else condition and using let statement\n* while loop statement and passing conditions while the statement is true\n* for loop and iteration\n"
        }
      ],
      "summaries": [
        {
          "title": "Control Flow",
          "shortTitle": "Control flow",
          "key": "control-flow",
          "details": "- In most cases, the computer runs the code in order from the first line in the file to the last line, unless it encounters structures that alter the control flow, such as loops and conditionals.\n- Many programming languages allow you to run some code depending on whether a condition is true, or run some code repeatedly while a condition is true. \n- If expressions and loops are the most common constructs in Rust that control execution flow.\n- We control the flow of our program with the following statements, in combination with relational comparison and logical operators.\n  * If else\n  * Match\n  * Loop\n  * For loop\n"
        },
        {
          "title": "If Expressions",
          "shortTitle": "If-else statement",
          "key": "if-else-let-statement",
          "details": "- To explore the if expression with combination with else we can choose to add one more condition with the else statement\n- We use if statement to give conditions to our code. You can branch your code based on conditions using an if expression. A condition is given and then a block of code is run if the condition is met. \n- In the event that the condition is not met, the compiler says to the machine “do not run this block.\"\n```rust\n  fn main() {\n    let number = 3;\n    if number < 5 {\n      println!(\"condition was true\");\n    } else {\n      println!(\"condition was false\");\n    }\n  }\n```\n- The keyword if follows a condition in all if expressions. \n- Here, the condition checks whether the variable number is less than 5.\n- Within curly brackets, we place the code to execute if the condition is true immediately after it.\n- Our program also includes an else expression, which we chose to use here, to provide an alternative block of code in case the condition is false.\n- Unless you provide an else expression, if the condition is false, the program will skip the if block and move on.\n  The following output should be seen after running this code:\n  ```rust\n    $ cargo run\n     Compiling branches v0.1.0 (file:///projects/branches)\n     Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n      Running `target/debug/branches`\n    condition was true\n  ```\n- If we change the `number` to 17 we get a `condition was false` because it is not less than 5. It is a very straight forward statement.\n"
        },
        {
          "title": "Multiple if conditions - how to evaluate them?",
          "shortTitle": "Nested if statement",
          "key": "if-statement",
          "details": "- Using conditional AND, you can test whether one condition and another are true. Before the code can be executed, both conditions must be met.\n- When AND is used to evaluate multiple conditions, the && operator is used to separate them.\n- The two logical operators && and || allow us to evaluate more than one condition in an if statement.\n  ```rust\n    fn main() {\n     let a = 5;\n     if a > 0 && a < 10 {\n         println!(\"Both conditions are true\");\n     }\n    }\n  ```\n- Due to the fact that both of our conditions are true in the example above, the code inside the if code block is executed.\n- It tests whether one condition or another is true by using the conditional OR. It is not necessary for both conditions to be true in order for the code to run.\n- The || operator is used to separate multiple conditions with OR.\n  ```rust\n    fn main() {\n      let a = 5;\n      if a > 5 || a < 10 {\n        println!(\"One of the conditions are true\");\n      }\n    }\n  ```\n"
        },
        {
          "title": "How to nest if, else if and else statements?",
          "shortTitle": "Nested if continues",
          "key": "nested-if-else-statement",
          "details": "- Nesting is the process of placing if statements inside other if statements. \n- By performing the evaluations hierarchically, the compiler will start at the outer if statement and work inwards.\n- We nest an if statement by writing it inside the execution code block of another if statement.\n```rust\nfn main() {\n let number = 5;\n if number < 10 {\n     // if outer condition proves\n     // true evaluate the inner if\n     if number > 0 {\n         println!(\"Inner if statement\");\n     }\n  }\n}\n```\n- In the example above, our outer if statement condition proves true. \n- The compiler then evaluates the inner if statement and executes its code block if its condition proves true.\n- Nested if statements are used when we want to evaluate conditions only if other conditions are true.\n- Note that if you find yourself nesting more than 3 levels deep, you should consider finding a different method. Perhaps a loop.\n"
        },
        {
          "title": "The conditional match statement",
          "shortTitle": "Match statement",
          "key": "match-statement",
          "details": "- The syntax is similar to a switch statement in a language in the C family, though the syntax is different.\n- A single value will be compared with a list of values with the match statement. It is a bit technical but easy so walk with me.\n- Taking it step by step will make it easier to understand what's going on.\n  1. The match statement returns a value, so we can assign the whole statement to a variable to get the result.\n    Example:\n     ```  let expression_result =```\n  2. Now we write the match statement itself. We use the keyword match, followed by the main value we are going to compare any other values to. Finally, we define a code block.\n    -  Note that the code block is terminated with a semicolon after the closing curly brace.\n    Example\n    ```rust\n    let expression_result = match main_value {\n       };\n    ```\n  3. Inside the code block we will write the values that we want to try and match with the main value.\n    - we specify the value we want to match, followed by a => operator.\n    - inside another code block, we specify the execution statements if that value matches with the main value.\n    - Each of these values are separated with a comma, and we can have as many as we need.\n    - The final value to match is simply an underscore. \n    - The single, standalone, underscore in a match statement represents a catch-all situation if none of the values matched to the main value.\n    - Think of it as an else statement.\n     Example:\n    ```rust\n     fn main() {\n      let grade = \"B\";\n      let _result = match grade {\n      \"A\" => { println!(\"Fantastic, you got an A!\"); },\n      \"B\" => { println!(\"Great job, you got a B!\"); },\n      \"C\" => { println!(\"Good job, you got a C\"); },\n      \"D\" => { println!(\"You got a D, you passed\"); },\n      \"F\" => { println!(\"Sorry, you failed\"); },\n      _ => { println!(\"Unknown grade, please see the teacher\"); }\n      };\n      }\n    ```\n- In the example above, we give a student a grade and store it in a variable.\n- Then we check to see which grade score in the match statement the student’s score matches.\n- If the compiler finds a match on the left of the ```=>``` operator, it will execute whatever statement is on the right of the ```=>``` operator.\n- In this case, it matched to “B” on the left and so it printed the string “Great job, you got a B!”.\n- Note that we don't use the result variable in the example above. This is simply because we don’t need to, the execution statement of the match already prints a message.\n- If we want to return an actual value, we specify the value instead of an action like ```println```.\nExample:\n```rust\n fn main() {\n  let grade = \"A\";\n  let result = match grade {\n     \"A\" => \"Excellent!\",\n     \"B\" => \"Great!\",\n     \"C\" => \"Good\",\n     \"D\" => \"You passed\",\n     \"F\" => \"Sorry, you failed\",\n     _ => \"Unknown Grade\"\n  };\n  println!(\"Grade: {} - {}\", grade, result);\n }\n```\n- In the example above, we replaced the ```println!()``` statements with simple string values.\n- When the compiler finds a match on the left of the``` =>``` operator, it will return the value on the right of the ```=> ```into the result variable.\n- This time, the compiler matched to “A” on the left, so it stored the string “Excellent!” into the result variable.\n- We then used it in the ```println!()``` below the match statement.\n"
        },
        {
          "title": "Loop statement",
          "shortTitle": "Loop",
          "key": "loop",
          "details": "- Throughout our application, we will often need to execute sections of code more than once. \n- Instead of rewriting these sections of code, we can place them in a loop and allow Rust to automatically execute them as many times as we need.\n- loop consists of the following\n * A condition\n     - A code block containing our execution code\n     - The compiler will evaluate the condition and based on its results, execute the code. Then, the compiler will start again at the top of the loop code and evaluate the condition again.\n     - This cycle of iterations continue until the condition is false, or we manually stop the loop.\n- Rust provides us with two types of loops\n  * The while loop\n  * The for loop\n  * The indefinite while loop\n- The while loop will continue to execute code while its condition remains true.\n- Once the condition proves false, the while loop will stop and the compiler will move on to any code below it.\n```rust\n  fn main() {\n  let mut counter = 0;\n  while counter < 10 {\n      println!(\"Counter: {}\", counter);\n      counter += 1;\n    }\n  }\n```\n- we set up a mutable variable called `counter`. This will help us stop the loop.\n- Next, we specify our condition that while the counter variable value is less than 10, the loop should iterate.\n- Inside the while code block, we print out the counter number to the console.\n- Lastly, we add 1 to our counter variable to indicate that the loop iterated once. When we run the example, the output shows a list of numbers from 1 to 10.\n Below is the expected output:\n```rust\n Counter: 0\n Counter: 1\n Counter: 2\n Counter: 3\n Counter: 4\n Counter: 5\n Counter: 6\n Counter: 7\n Counter: 8\n Counter: 9\n```\n- Every time the compiler goes through the code it prints the ``` mut counter``` and add 1 to it until it is great than 10.\n"
        },
        {
          "title": "Infinite loops",
          "shortTitle": "Infinite loops",
          "key": "infinite-loops",
          "details": "- With the while loop, there is a potential danger that the loop may never stop if we make a mistake. \n- This is known as an infinite loop and it will significantly slow down the system until the application crashes.\n- Lets use our earlier example. If we remove the code that increments the counter, the condition will always prove true because the counter will stay at 0 and never get to 10 where it’s told to stop.\n- This section of code will cause an infinite loop\n```rust\n fn main() {\n  let mut counter = 0;\n   while counter < 10 {\n  println!(\"Counter: {}\", counter);\n   }\n}\n```\n- The loop keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop. \n- showing looping with examples \n- As an example, change the src/main.rs file in your loops directory to look like this\n```rust\nfn main() {\n loop {\n     println!(\"again!\");\n   }\n  }\n```\n - When we run this program, we'll see again! printed over and over continuously until we stop the program manually.\n - Most terminals support the keyboard shortcut ctrl-c to interrupt a program that is stuck in a continual loop. \n - This will be the ouput:\n```rust\n  again!\n  again!\n  again!\n  again!\n  ^Cagain!\n```\n- The symbol ^C represents where you pressed ctrl-c .\n- You may or may not see the word again! printed after the ^C, depending on where the code was in the loop when it received the interrupt signal.\n- Fortunately, Rust also provides a way to break out of a loop using code. You can place the break keyword within the loop to tell the program when to stop executing the loop.\n- Recall that we did this in the guessing game in the “Quitting After a Correct Guess” section of Chapter 2 to exit the program when the user won the game by guessing the correct number.\n- We also used continue in the guessing game, which in a loop tells the program to skip over any remaining code in this iteration of the loop and go to the next iteration.\n"
        },
        {
          "title": "Returning Values from Loops",
          "shortTitle": "Value from loops",
          "key": "looping-value",
          "details": "- One of the uses of a loop is to retry an operation you know might fail, such as checking whether a thread has completed its job. \n- You might also need to pass the result of that operation out of the loop to the rest of your code.\n- To do this, you can add the value you want returned after the break expression you use to stop the loop; \n- that value will be returned out of the loop so you can use it, as shown here:\n```rust\n  fn main() {\n   let mut counter = 0;\n   let result = loop {\n    counter += 1;\n    if counter == 10 {\n        break counter * 2;\n     }\n   };\n println!(\"The result is {result}\");\n }\n```\n- Before the loop, we declare a variable named counter and initialize it to 0.\n- Then we declare a variable named result to hold the value returned from the loop.\n- On every iteration of the loop, we add 1 to the counter variable, and then check whether the counter is equal to 10.\n- When it is, we use the break keyword with the value counter * 2.\n- After the loop, we use a semicolon to end the statement that assigns the value to result.\n- Finally, we print the value in result, which in this case is 20.\n- Loop Labels to Disambiguate Between Multiple Loops\n- If you have loops within loops, break and continue apply to the innermost loop at that point. \n- You can optionally specify a loop label on a loop that we can then use with break or continue to specify that those keywords apply to the labeled loop instead of the innermost loop. Loop labels must begin with a single quote. \n- Here's an example with two nested loops:\n```rust\n  fn main() {\n   let mut count = 0;\n   'counting_up: loop {\n     println!(\"count = {count}\");\n     let mut remaining = 10;\n     loop {\n         println!(\"remaining = {remaining}\");\n         if remaining == 9 {\n             break;\n          }\n         if count == 2 {\n             break 'counting_up;\n         }\n         remaining -= 1;\n     }\n     count += 1;\n }\n println!(\"End count = {count}\");\n}\n```\n- The outer loop has the label 'counting_up', and it will count up from 0 to 2. \n- The inner loop without a label counts down from 10 to 9.\n- The first break that doesn’t specify a label will exit the inner loop only.\n- The break 'counting_up; statement will exit the outer loop. \n This code prints:\n ```rust\n count = 0\n remaining = 10\n remaining = 9\n count = 1\n remaining = 10\n remaining = 9\n count = 2\n remaining = 10\n End count = 2\n```\n"
        },
        {
          "title": "For Loop",
          "shortTitle": "For loop statement",
          "key": "for-loop-statement",
          "details": "- A 'for' expression is a syntactic construct for looping over elements provided by an implementation of std::iter::IntoIterator.\n- If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the for loop.\n- If the iterator is empty, the 'for' expression completes.\n- The safety and conciseness of for loops make them the most commonly used loop construct in Rust\n- Using the for loop, you wouldn't need to remember to change any other code if you changed the number of values in the array,\n- An example of a for loop over the contents of an array:\n```rust\n fn main() {\n  let v = &[\"apples\", \"cake\", \"coffee\"];\n for text in v {\n println!(\"I like {}.\", text);\n }\n }\n ```\n - An example of a for loop over a series of integers:\n```rust\n let mut sum = 0;\n for n in 1..11 {\n sum += n;\n}\n assert_eq!(sum, 55);\n```\n- A 'for' loop is equivalent to a loop expression containing a match expression as follows:\n```rust\n'label: for PATTERN in iter_expr {\n    /* loop body */\n }\n```\n"
        },
        {
          "title": "Error Handling",
          "shortTitle": "Errors",
          "key": "error-handling",
          "details": "- Errors are inevitable in software, so Rust has a number of features to help you deal with them. When an error occurs, Rust requires you to acknowledge it and take action before your code can be compiled. \n- By requiring this requirement, you ensure that you will discover errors before deploying your code to production and that they will be handled appropriately.\n- There are two major categories of errors in Rust:\n  * recoverable and\n  * unrecoverable. \n- Typically, we want to notify the user of a recoverable error, such as a file not found error, and then retry the operation.\n- The program should be immediately stopped if an unrecoverable error occurs, such as accessing a location beyond the end of an array.\n- It is common for languages to handle both kinds of errors in the same way, using mechanisms such as exceptions. Rust doesn’t have exceptions.\n- Instead, it has the type Result<T, E> for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error.\n- This chapter covers calling panic! first and then talks about returning Result<T, E> values. Additionally, we’ll explore considerations when deciding whether to try to recover from an error or to stop execution.\n"
        },
        {
          "title": "Unrecoverable Errors with panic!",
          "shortTitle": "Panic",
          "key": "panic-error-catching",
          "details": "- When the panic! macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.\n- We’ll commonly invoke a panic when a bug of some kind has been detected and it’s not clear how to handle the problem at the time we’re writing our program.\n- Let's try calling panic! in a simple program:\n  Filename: src/main.rs\n   ```rust\n      This code panics!\n      fn main() {\n        panic!(\"crash and burn\");\n      }\n   ```\n- If we run this code this is what we get\n   ```rust\n     $ cargo run\n     Compiling panic v0.1.0 (file:///projects/panic)\n       Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n       Running `target/debug/panic`\n      thread 'main' panicked at 'crash and burn', src/main.rs:2:5\n   ```\n- note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n  - The call to panic! causes the error message contained in the last two lines. \n- The first line shows our panic message and the place in our source code where the panic occurred\n"
        },
        {
          "title": "To panic! or Not to panic!",
          "shortTitle": "panic! or Not Panic",
          "key": "panic-not-panic",
          "details": "- This covers how do you decide when you should call panic! and when you should return Result? When code panics, there’s no way to recover. \n- You could call panic! for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision that a situation is unrecoverable on behalf of the calling code. When you choose to return a Result value, you give the calling code options. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an Err value in this case is unrecoverable, so it can call panic! and turn your recoverable error into an unrecoverable one. \n- Therefore, returning Result is a good default choice when you’re defining a function that might fail.\n- Option Enum\n   * Option is a predefined enum in the Rust standard library. This enum has two values − Some(data) and None.\n- Syntax:\n  ```rust\n     enum Option<T> {\n       Some(T), //used to return a value\n       None // used to return null, as Rust doesn't support\n       the null keyword\n     }\n  ```\n- Here, the type T represents value of any type.\n- Rust does not support the null keyword. \n- The value None, in the enumOption, can be used by a function to return a null value.\n- If there is data to return, the function can return Some(data).\n- The program defines a function is_even(), with a return type Option. \n- The function verifies if the value passed is an even number.\n- If the input is even, then a value true is returned, else the function returns None.\n  ```rust\n    fn main() {\n     let result = is_even(3);\n     println!(\"{:?}\",result);\n     println!(\"{:?}\",is_even(30));\n    } \n    fn is_even(no:i32)->Option<bool> {\n     if no%2 == 0 {\n        Some(true)\n     } else {\n        None\n     }\n    }\n  ```\n- Output:\n  ```rust\n    None\n    Some(true)\n  ```\n- When we are not sure whether there is a character at 6th element and you don\"'\"t want your program to crash, Option comes to the rescue. \n- Here is another example from The Rust Programming Language:\n  ```rust\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n       match x {\n          None => None,\n          Some(i) => Some(i + 1),\n      }\n    }\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n  ```\n"
        },
        {
          "title": "Recoverable Errors with Result",
          "shortTitle": "Result option",
          "key": "result-option",
          "details": "- Most errors aren’t serious enough to require the program to stop entirely. Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to.\n- For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.\n- Handling Potential Failure with the Result Type in Rust language is defined as having two variants,\n   * Ok and \n   * Err \n\n    ```rust\n      enum Result<T, E> {\n         Ok(T),\n         Err(E),\n      } \n    ```\n- The T and E are generic type parameters. \n   - What you need to know right now is that T represents the type of the value that will be returned in a success case within the Ok variant, and E represents the type of the error that will be returned in a failure case within the Err variant. \n   - Because Result has these generic type parameters, we can use the Result type and the functions defined on it in many different situations where the successful value and error value we want to return may differ.\n- Let’s call a function that returns a Result value because the function could fail. \n- Filename: src/main.rs:\n  ```rust\n    use std::fs::File;\n    fn main() {\n       let f = File::open(\"hello.txt\");\n    }\n  ```\n- Opening a file:\n- How do we know File::open returns a Result? \n   - We could look at the standard library API documentation, or we could ask the compiler! \n   - If we give f a type annotation that we know is not the return type of the function and then try to compile the code, the compiler will tell us that the types don’t match. \n   - The error message will then tell us what the type of f is. \n- Let's try it! We know that the return type of File::open isn’t of type u32, so let’s change the let f statement to this:\n- example: \n- This code does not compile!\n  ```rust\n      let f: u32 = File::open(\"hello.txt\");\n  ```    \n- Attempting to compile now gives us the following output:\n  ```rust\n     $ cargo run\n       Compiling error-handling v0.1.0 (file:///projects/error-handling)\n       error[E0308]: mismatched types\n      --> src/main.rs:4:18\n       |\n     4 |     let f: u32 = File::open(\"hello.txt\");\n       |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`\n       |            |\n       |            expected due to this\n       |\n       = note: expected type `u32`\n                  found enum `Result<File, std::io::Error>`\n      For more information about this error, try `rustc --explain E0308`.\n      error: could not compile `error-handling` due to previous error\n    ```\n"
        },
        {
          "title": "Propagating Errors",
          "shortTitle": "propagating error",
          "key": "propagating-errors",
          "details": "- When a function's implementation calls something that might fail, instead of handling the error within the function itself, you can return the error to the calling code so that it can decide what to do. \n- This is known as propagating the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.\n- A Shortcut for Propagating Errors: the ? Operator\n- The code below shows an implementation of read_username_from_file that has the same functionality as in Listing 9-6, but this implementation uses the ? operator.\n- Filename: src/main.rs\n```rust\n use std::fs::File;\n use std::io;\n use std::io::Read;\n fn read_username_from_file() -> Result<String, io::Error> {\n   let mut f = File::open(\"hello.txt\")?;\n   let mut s = String::new();\n   f.read_to_string(&mut s)?;\n  Ok(s)\n }\n```\n- This function that returns errors to the calling code using the ? operator\n- The ? placed after a Result value is defined to work in almost the same way as the match expressions we defined to handle the Result values in Listing 9-6. If the value of the Result is an Ok, the value inside the Ok will get returned from this expression, and the program will continue. If the value is an Err, the Err will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code.\n- The ? operator eliminates a lot of boilerplate and makes this function’s implementation simpler.\n- The ? operator can only be used in functions whose return type is compatible with the value the ? is used on. This is because the ? operator is defined to perform an early return of a value out of the function.\n"
        },
        {
          "title": "Functions",
          "shortTitle": "functions",
          "key": "functions",
          "details": "- Functions are prevalent in Rust code. You've already seen one of the most important functions in the language. \n- The main function, which is the entry point of many programs. \n- You've also seen the fn keyword, which allows you to declare new functions.\n- Rust code uses snake case as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words.\n- Here's a program that contains an example function definition:\n- Filename: src/main.rs\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n   another_function();\n}\nfn another_function() {\n   println!(\"Another function.\");\n }\n```\n"
        },
        {
          "title": "Start with Fn",
          "shortTitle": "start with fn",
          "key": "fn-keyword",
          "details": "- We define a function in Rust by entering `fn` followed by a function name and a set of parentheses. \n- The curly brackets `{...}` tell the compiler where the function body begins and ends.\n- We can call any function we've defined by entering its name followed by a set of parentheses. Because another_function is defined in the program, it can be called from inside the main function. Note that we defined another_function after the main function in the source code; we could have defined it before as well.  \n- Rust doesn't care where you define your functions, only that they’re defined somewhere in a scope that can be seen by the caller.\n- Let's start a new binary project named functions to explore functions further.\n- Place the another_function example in src/main.rs (see above)and run it. You should see the following output:\n```rust\n $ cargo run\n    Compiling functions v0.1.0 (file:///projects/functions)\n     Finished dev [unoptimized + debuginfo] target(s) in 0.28s\n     Running `target/debug/functions`\n Hello, world!\n Another function.\n ```\n- The lines execute in the order in which they appear in the main function. \n- First, the “Hello, world!” message prints, and then another_function is called and its message is printed.\n"
        },
        {
          "title": "Function names",
          "shortTitle": "function name",
          "key": "function-name",
          "details": "- Often involve type names, the most common example being conversions like as_slice. \n- If the type has a purely textual name (ignoring parameters), it is straightforward to convert between type conventions and function conventions.\n- The Rust compiler is very opinionated about what casing and style you use to name things, even giving warnings when you break its rules. You can disable those warnings if you wish. \n- Here is a quick overview of the rules:\n\n  | Convention | Types that use it |\n  | ---------- | ----------------- |\n  | `snake_case` | Crates, modules, functions, methods, local variables and parameters, lifetimes. |\n  | `CamelCase` | Types (including traits and enums), type parameters in generics. |\n  | `SCREAMING_SNAKE_CASE` | Constant and static variables. |\n\n- This means that when you have a type name and you want to refer to it in a function name, you have to convert. So YourType will become your_type\n\n  | Type name | Text in methods |\n  | --------- | --------------- |\n  | String | string |\n  | Vec<T> |\tvec |\n  | YourType | your_type |\n\n- Types that involve notation follow the convention below. There is some overlap on these rules; apply the most specific applicable rule:\n\n  | Type name | Text in methods |\n  | --------- | --------------- |\n  | &str | str |\n  | &[T] | slice |\n  | &mut [T] | mut_slice |\n  | &[u8] | bytes |\n  | &T | ref |\n"
        },
        {
          "title": "Statements and Expressions",
          "shortTitle": "Function body",
          "key": "statement-expression",
          "details": "- The block of a function is conceptually wrapped in a block that binds the argument patterns and then returns the value of the functions block.\n- The tail expression of the block, if evaluated, ends up being returned to the caller. \n- As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.\n- Function bodies are made up of a series of statements optionally ending in an expression.\n- So far, the functions we’ve covered haven’t included an ending expression, but you have seen an expression as part of a statement.\n- Because Rust is an expression-based language, this is an important distinction to understand. \n- Other languages don’t have the same distinctions, so let’s look at what statements and expressions are and how their differences affect the bodies of functions.\n- Statements are instructions that perform some action and do not return a value. Expressions evaluate to a resulting value.\n - For example, the function above behaves as if it was written as:\n  - Filename: src/main.rs\n  ```rust\n    fn main() {\n      let y = 6;\n    }\n  ```\n- Function definitions are also statements; the entire preceding example is a statement in itself.\n- Statements do not return values. \n- Therefore, you can’t assign a let statement to another variable, as the following code tries to do; you’ll get an error\n  ```rust   \n    fn main() {\n       let x = (let y = 6);\n    }\n  ```\n- When you run this program, the error you’ll get looks like this\n  ```rust\n    $ cargo run\n      Compiling functions v0.1.0 (file:///projects/functions)\n    error: expected expression, found statement (`let`)\n     --> src/main.rs:2:14\n      |\n    2 |     let x = (let y = 6);\n      |              ^^^^^^^^^\n      |\n      = note: variable declaration using `let` is a statement\n     error[E0658]: `let` expressions in this position are experimental\n      --> src/main.rs:2:14\n      |\n    2 |     let x = (let y = 6);\n      |              ^^^^^^^^^\n      |\n      = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n      = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n      warning: unnecessary parentheses around assigned value\n      --> src/main.rs:2:13\n      |\n    2 |     let x = (let y = 6);\n      |             ^         ^\n      |\n      = note: `#[warn(unused_parens)]` on by default\n      help: remove these parentheses\n      |\n      2 -     let x = (let y = 6);\n      2 +     let x = let y = 6;\n      | \n     For more information about this error, try `rustc --explain E0658`.\n    warning: `functions` (bin \"functions\") generated 1 warning\n    error: could not compile `functions` due to 2 previous errors; 1 warning emitted\n  ```\n- Functions without a body block are terminated with a semicolon. This form may only appear in a trait or external block.\n"
        },
        {
          "title": "Option and Result",
          "shortTitle": "Option and Result",
          "key": "option-result",
          "details": "- Many languages use null\\ nil\\ undefined types to represent empty outputs, and Exceptions to handle errors. \n- Rust skips using both, especially to prevent issues like null pointer exceptions, sensitive data leakages through exceptions and etc. \n- Instead, Rust provides two special generic enums;Option and Result to deal with above cases.\n   * An optional value can have either Some value or no value/ None.\n   * A result can represent either success/ Ok or failure/ Err\n```rust\n  // An output can have either Some value or no value/ None.\n   enum Option<T> { // T is a generic and it can contain any type of value.\n   Some(T),\n    None,\n }\n```\n   OR\n \n```rust\n// A result can represent either success/ Ok or failure/ Err.\nenum Result<T, E> { // T and E are generics. T can contain any type of value, E can be any error.\n   Ok(T),\n   Err(E),\n}\n```\n"
        },
        {
          "title": "Basic usages of Option",
          "shortTitle": "Option",
          "key": "options",
          "details": "- When writing a function or data type,\n  * if an argument of the function is optional,\n  * If the function is non-void and if the output it returns can be empty,\n  * If the value, of a property of the data type can be empty, We have to use their data type as an Option type\n \n - For example, if the function outputs a &str value and the output can be empty, the return type of the function should set as Option<&str>.\n ```rust\n  fn get_an_optional_value() -> Option<&str> {\n     //if the optional value is not empty\n     return Some(\"Some value\");\n \n    //else\n    None\n }\n ```\n"
        },
        {
          "title": "List of Programming arguments",
          "shortTitle": "Arguments",
          "key": "arguments",
          "details": "- In programming, a value that is passed between programs, subroutines or functions\n- Arguments are independent items, or variables, that contain data or codes.\n- When an argument is used to customize a program for a user, it is typically called a \"parameter.\"\n- We can define functions to have parameters, which are special variables that are part of a function’s signature. \n- When a function has parameters, you can provide it with concrete values for those parameters.\n- Technically, the concrete values are called arguments, but in casual conversation, people tend to use the words parameter and argument interchangeably for either the variables in a function’s definition or the concrete values passed in when you call a function.\n- In this version of another_function we add a parameter:\n- Filename: src/main.rs\n```rust\n fn main() {\n  another_function(5);\n}\nfn another_function(x: i32) {\n  println!(\"The value of x is: {x}\");\n}\n```\n- Try running this program; you should get the following output:\n```rust\n  $ cargo run\n  Compiling functions v0.1.0 (file:///projects/functions)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.21s\n    Running `target/debug/functions`\n   The value of x is: 5\n```\n- The declaration of `another_function` has one parameter named x.\n- The type of x is specified as i32. When we pass 5 in to another_function, the println! macro puts 5 where the pair of curly brackets containing x was in the format string.\n- In function signatures, you must declare the type of each parameter. \n- This is a deliberate decision in Rust’s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what type you mean. \n- The compiler is also able to give more helpful error messages if it knows what types the function expects.\n- When defining multiple parameters, separate the parameter declarations with commas, like this:\n- Filename: src/main.rs\n```rust\nfn main() {\n  print_labeled_measurement(5, 'h');\n}\n fn print_labeled_measurement(value: i32, unit_label: char) {\n  println!(\"The measurement is: {value}{unit_label}\");\n}\n```\n- This example creates a function named print_labeled_measurement with two parameters. \n- The first parameter is named value and is an i32. The second is named unit_label and is type char. \n- The function then prints text containing both the value and the unit_label.\n\n- Let's try running this code. \n- Replace the program currently in your functions project's src/main.rs file with the preceding example and run it using cargo run:\n```rust\n  $ cargo run\n  Compiling functions v0.1.0 (file:///projects/functions)\n  Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n   Running `target/debug/functions`\n   The measurement is: 5h\n```\n- Because we called the function with 5 as the value for value and 'h' as the value for unit_label, the program output contains those values.\n"
        }
      ]
    },
    {
      "title": "OOPS(Object Oriented Programming)",
      "key": "oops",
      "details": "This chapter covers all the important object oriented programming concepts with rust.\n - Structs\n    1. Introduction and Defining a Struct\n    2. Different types of structs\n      a. Classic\n      b. Tuple\n      c. Unit\n    3. Creating new instances of a struct\n    4. Destructing\n - Enums\n    1. Introduction and Defining Enums\n    2. Declaring Enums using types\n    3. Option and Result type Enums\n      a. Option Enum Advantages over NULL values\n    4. Difference between Enums and Strcuts\n - Traits\n    1. Introduction and Defining Traits\n    2. Different Types of Traits\n      a. Marker\n      b. Simple\n      c. Generic\n      d. Associated\n      e. Inherited\n    3. Trait Bounds\n      a. Trait Bounds on types\n      b. on generic functions, \n      c. on impl blocks, \n      d. ‘+’ to compose trait bounds\n    4. Standard Library Traits\n    5. Polymorphism using trait objects \n      a. Dispatch\n      b. Trait Objects\n",
      "order": 3,
      "questions": [
        {
          "uuid": "ab88a2ab-c80b-49f5-9ea0-b5ed8e4933b1",
          "type": "SingleChoice",
          "content": "What is the output of the following code snippet:\n \n    ``` \n        fn main() {\n          let x = 12;\n          println!(\"The value of x is: {x}\");\n          x = 8;\n          println!(\"The value of x is: {x}\");\n        } \n    ```\n",
          "hint": "NoHint",
          "explanation": "Error would occur, because the variable x isn't set as mutable so it's value can't be changed.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The value of x is: 8",
              "key": "A"
            },
            {
              "content": "Error: the variable x is mutable",
              "key": "B"
            },
            {
              "content": "The value of x is: 12",
              "key": "C"
            },
            {
              "content": "Error: the variable x is immutable",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "23a0e9e5-6c47-4512-98a5-4cd3ab6eff25",
          "type": "SingleChoice",
          "content": "Space taken by a Character data type in rust is",
          "hint": "It doesn't use ASCII values",
          "explanation": "Rust's char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1 byte",
              "key": "A"
            },
            {
              "content": "4 bytes",
              "key": "B"
            },
            {
              "content": "8 bytes",
              "key": "C"
            },
            {
              "content": "16 bytes",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "39385b22-7604-492f-9c2e-aaae409c6b79",
          "type": "SingleChoice",
          "content": "Rust is a Dynamically typed language.",
          "hint": "Does the compiler need to know the data type at compile time?",
          "explanation": "It is statically typed",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "6b844c24-f769-4662-a591-83c0a5f8c6c3",
          "type": "SingleChoice",
          "content": "Select the incorrect declaration statement",
          "hint": "NoHint",
          "explanation": "It is declared as an unsigned integer, but the value is negative",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let mut x: u32 = 20;",
              "key": "A"
            },
            {
              "content": "let mut x: i32 = -20;",
              "key": "B"
            },
            {
              "content": "let mut x: u32 = -20;",
              "key": "C"
            },
            {
              "content": "let mut x = 20;",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6f2cb4ae-db4d-4c04-bfd4-37669695dab0",
          "type": "SingleChoice",
          "content": "Suppose you declared a variable as u8 and then assigned it a value of \"257\". What would be the output if it’s compiled with a \"`“--release” flag?`\"",
          "hint": "NoHint",
          "explanation": "After 255 the digits start rolling back to 0, 1 and so on",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "257",
              "key": "A"
            },
            {
              "content": "Error: Integer Overflow",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0708f185-46b5-45ee-ac47-3e7e1ca611b3",
          "type": "SingleChoice",
          "content": "Are Tuples in rust dynamic in nature?\n\"Eg:-\" \n``` \n  let tup: (i32, f64, bool) = (500, 6.4, true); \n```\n",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Yes",
              "key": "A"
            },
            {
              "content": "No",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d11a531f-f32f-4764-a60a-2cc5af348245",
          "type": "SingleChoice",
          "content": "Select the correct statements for the two String     types(“String” and “&str”).\n \"a. “Strings” are immutable in nature and cannot be modified. \"\n \"b. “&str” is a primitive data type, whereas “String” is implemented in the standard library.\"\n \"c. To read a file into the strings, we use the read_to_string() method.\"\n",
          "hint": "NoHint",
          "explanation": "Strings are mutable in nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Only a",
              "key": "A"
            },
            {
              "content": "Both a & b",
              "key": "B"
            },
            {
              "content": "Both b & c",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9511276a-dd19-47c4-b086-0d1de8cafedb",
          "type": "SingleChoice",
          "content": "Which among the following is not an acceptable keyword in rust?",
          "hint": "NoHint",
          "explanation": "var is not a keyword in rust",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "let",
              "key": "A"
            },
            {
              "content": "var",
              "key": "B"
            },
            {
              "content": "impl",
              "key": "C"
            },
            {
              "content": "mut",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1ed70de2-99c6-43dd-8793-40ad702d6bff",
          "type": "SingleChoice",
          "content": "Which of the following brackets are used as placeholders in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "{}",
              "key": "A"
            },
            {
              "content": "[ ]",
              "key": "B"
            },
            {
              "content": "( )",
              "key": "C"
            },
            {
              "content": "< >",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7f129510-4d19-4a62-bae1-34109714fa0e",
          "type": "SingleChoice",
          "content": "Constants in rust can be defined in which scope?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Global",
              "key": "A"
            },
            {
              "content": "Method",
              "key": "B"
            },
            {
              "content": "Local",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b29fa10c-2efa-478c-8207-2e2a80af8700",
          "type": "SingleChoice",
          "content": "Which of the following are the scalar data types present in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "integers, floating-point numbers, booleans, characters",
              "key": "A"
            },
            {
              "content": "integers, signed numbers, unsigned numbers, booleans, characters",
              "key": "B"
            },
            {
              "content": "integers, strings, signed numbers, unsigned numbers, booleans",
              "key": "C"
            },
            {
              "content": "integers, floating-point numbers, strings, booleans",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "775949c1-23b7-42bc-b184-bc755c8d2657",
          "type": "SingleChoice",
          "content": "The compound data types supported by rust are-",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays, Lists, Red-Black Trees",
              "key": "A"
            },
            {
              "content": "Arrays, Lists, Vectors",
              "key": "B"
            },
            {
              "content": "Arrays, Tuples",
              "key": "C"
            },
            {
              "content": "Arrays, Maps",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7fd341f0-4921-4e6e-aa0c-c3897f91d3b2",
          "type": "SingleChoice",
          "content": "Which are valid array declarations in rust? \n``` \n       let mut arr : {i64, 3} = [2,3,5];\n       let mut arr : {3,3};\n       let mut arr = [2,3,5];\n ```\n",
          "hint": "Look for the wrong declaration format, you may or may not find it",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both a & b",
              "key": "A"
            },
            {
              "content": "Both b & c",
              "key": "B"
            },
            {
              "content": "Only a",
              "key": "C"
            },
            {
              "content": "All a, b, & c",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "75d926cd-6f05-4185-916c-fc6c2b90eecd",
          "type": "SingleChoice",
          "content": "Which of the following has low memory usage, const or static?",
          "hint": "How many of these can we update?",
          "explanation": "Constant doesn't uses any extra heap memory to update",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "const",
              "key": "A"
            },
            {
              "content": "static",
              "key": "B"
            },
            {
              "content": "depends upon the data type",
              "key": "C"
            },
            {
              "content": "both have the same memory usage",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a7495120-1470-41d4-aeb2-6d9d7ebd876c",
          "type": "SingleChoice",
          "content": "To use dynamic-sized variables, which of the following should be used?",
          "hint": "No hint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Arrays & Tuples",
              "key": "A"
            },
            {
              "content": "List all the data types",
              "key": "B"
            },
            {
              "content": "Sized",
              "key": "C"
            },
            {
              "content": "Dynamic-Sized variables not supported in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4c564a7d-28d3-4fca-a06d-f3f3fc419d13",
          "type": "SingleChoice",
          "content": "What is the importance of the “type” keyword in rust?",
          "hint": "Used for another types.",
          "explanation": "Sets an alias of another type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "used for dynamic-sized data type",
              "key": "A"
            },
            {
              "content": "used to create a template",
              "key": "B"
            },
            {
              "content": "used for user-defined data type",
              "key": "C"
            },
            {
              "content": "used to set an alias of another type",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d677a228-7f5d-4b5f-8bee-9f40052efafb",
          "type": "SingleChoice",
          "content": "What is the importance of Cargo in rust?",
          "hint": "What is npm used for?",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "package-manager"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Collection of rust libraries",
              "key": "A"
            },
            {
              "content": "Modules Package manager",
              "key": "B"
            },
            {
              "content": "Build system and Package manager",
              "key": "C"
            },
            {
              "content": "Used to create and build UI projects in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2715ab2c-35b3-4e6a-9697-f244c6e23676",
          "type": "SingleChoice",
          "content": "How to print the data type of a variable in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": " `std::any::type_name` ",
              "key": "A"
            },
            {
              "content": " `variable.type_name()` ",
              "key": "B"
            },
            {
              "content": " `std::intrisic::type_name` ",
              "key": "C"
            },
            {
              "content": " `std::variable::type_name` ",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e326751d-bb65-44e4-a6ce-fa62faa96f94",
          "type": "SingleChoice",
          "content": "Which type cast preserves the mathematical value in all cases?",
          "hint": "NoHint",
          "explanation": "Because they can handle both signed and unsigned values, and are typecasted in one data type only.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "i32 as i64",
              "key": "A"
            },
            {
              "content": "i64 as i32",
              "key": "B"
            },
            {
              "content": "usize as u64",
              "key": "C"
            },
            {
              "content": "f64 as f32",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ffac79fe-2367-42d1-82eb-b6e6127aead5",
          "type": "SingleChoice",
          "content": "Which of the following cannot be destructed further into smaller segments?",
          "hint": "Think of the structures they're built upon ",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Tuples",
              "key": "A"
            },
            {
              "content": "Traits",
              "key": "B"
            },
            {
              "content": "Arrays",
              "key": "C"
            },
            {
              "content": "Structs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b0a3444-3b86-4e09-8021-f4b66cb2ce09",
          "type": "SingleChoice",
          "content": "Which comment syntax is not legal?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "<//>",
              "key": "A"
            },
            {
              "content": "/* */",
              "key": "B"
            },
            {
              "content": "//!",
              "key": "C"
            },
            {
              "content": "//",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f9d0f0d-4670-44d7-b69f-d398ecfb3236",
          "type": "SingleChoice",
          "content": "Values of the array can be deleted.",
          "hint": "NoHint",
          "explanation": "Values can be updated, but can't be deleted",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d2af3b88-9912-4729-9673-4101b7ec4765",
          "type": "SingleChoice",
          "content": "How do you initialize every element of an array of size 5 with 0?",
          "hint": "Look at the declarations, don't get confused by the order while declaring",
          "explanation": "The first argument is the integer you want to initialize an element with, and the second argument tells the end posistion till where you want to pre-initialize.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "`let mut arr : {i32;5} = {5;0};`",
              "key": "A"
            },
            {
              "content": "`let mut arr : {i32;5} = {0;5};`",
              "key": "B"
            },
            {
              "content": "`let mut arr : {5;i32} = {5;0};`",
              "key": "C"
            },
            {
              "content": "`let mut arr : {5;i32} = {0;5};`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "93c0673c-a86b-4bbb-82b0-3bb77bddab67",
          "type": "SingleChoice",
          "content": "Tuples in rust are",
          "hint": "NoHint",
          "explanation": "They can handle and store different data types",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "finite heterogeneous compound data types",
              "key": "A"
            },
            {
              "content": "finite homogeneous compound data types",
              "key": "B"
            },
            {
              "content": "infinite heterogeneous compound data types",
              "key": "C"
            },
            {
              "content": "infinite homogeneous compound data types",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8c7f2429-0db2-4288-bd4a-ef694b39206c",
          "type": "SingleChoice",
          "content": "What would be the output of the following code snippet?\n  ```\n    Fn main( ) {\t\n      let mut dodao_io = (\"\"Do\"\", 69, \"\"DAO\"\", 420);\n      println!(\"\"{} \"\", dodao_io );\n      println!(\"\"at 0 index = {} \"\", gfg.0 );\n    } \n  ```\n",
          "hint": "No Hint",
          "explanation": "The first print statement should've had {;?}",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & Do",
              "key": "A"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) only",
              "key": "B"
            },
            {
              "content": "Compilation Error",
              "key": "C"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & “Do”",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f6ce66c-3d34-4fa0-b6f6-188b7aa052b9",
          "type": "SingleChoice",
          "content": "What is the process of temporarily making a variable mutable known as?",
          "hint": "NoHint",
          "explanation": "No explantion",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Pseudo-mutability",
              "key": "A"
            },
            {
              "content": "Foreshadowing",
              "key": "B"
            },
            {
              "content": "Shadowing",
              "key": "C"
            },
            {
              "content": "Overshadowing",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d8a49f56-5da8-4b71-b18c-e745d5913dee",
          "type": "SingleChoice",
          "content": "Which of the following is an example of suffix annotation?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let a_int: i64 = 20;",
              "key": "A"
            },
            {
              "content": "let a_int = i6420;",
              "key": "B"
            },
            {
              "content": "let a_int = 20i64;",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "419058bf-87e9-4c18-9b8e-3f96c3c820b3",
          "type": "SingleChoice",
          "content": "A. println!(\"1 + 2 = {}\", 1u32 + 2);\nB. println!(\"1 - 2 = {}\", 1u32 + 2);\n",
          "hint": "Solution being Positive or Negative might make a difference",
          "explanation": "Here, when initialized, 1 is set as unsigned 32 integer u32. In statement A, it works because  1+2=3, and it's positive. But, 1-2=(-1) and as they were unsigned integers, so they cannot hold a negative value, so this statement doesn't compile\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Only A compiles",
              "key": "A"
            },
            {
              "content": "Only B compiles",
              "key": "B"
            },
            {
              "content": "Both A & B compile",
              "key": "C"
            },
            {
              "content": "None of them complies",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d97fc146-6c06-4a5c-a738-93a00cf7214e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n\"``` println!(\"{}\", 1_00u32 + 2_0); ```\"\n",
          "hint": "NoHint",
          "explanation": "1_000u32 is similar as 100 of u32 type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Compilation Error",
              "key": "A"
            },
            {
              "content": "Runtime Error",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "120",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2448d741-4c38-46f3-b681-c3ffb44e54ac",
          "type": "SingleChoice",
          "content": "String in standard library has more functionalities coded into it than string slice?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "923d11ba-5c1c-4d48-8101-87ee08e0fa0e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n  ```\n  fn main() {\n    let first_string = \"This is some string \".to_string();\n    let second_string = \"Let's add some Data\";\n\n    let final_string = first_string + &second_string;\n\n    println!(\"First string is: {}\", first_string);   \n    println!(\"Second string is: {}\", second_string);\n\n    println!(\"Finally we have: {}\", final_string);\n  }\n  ```\n",
          "hint": "NoHint",
          "explanation": "Syntatical Error in the code snippet",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Only 1st print statement shows an output",
              "key": "A"
            },
            {
              "content": "Only 1st and 2nd print statement shows an output",
              "key": "B"
            },
            {
              "content": "All the 3 string statements show an output",
              "key": "C"
            },
            {
              "content": "Error occurs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ec5e9c9b-cafa-484e-8feb-51db5a0b7a33",
          "type": "SingleChoice",
          "content": "Which of the following operator is used by string slices to reference?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`&`",
              "key": "A"
            },
            {
              "content": "`%`",
              "key": "B"
            },
            {
              "content": "`#`",
              "key": "C"
            },
            {
              "content": "`*`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d0b24301-eda6-49d7-bf45-88777b13e15f",
          "type": "SingleChoice",
          "content": "Select the incorrect statement from the following",
          "hint": "Nohint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Once you get a string slice from a string, then you cannot really                 modify that String anymore",
              "key": "A"
            },
            {
              "content": "Using slices to work with Strings allows us to add an extra                       security measure.",
              "key": "B"
            },
            {
              "content": "If you attempt to create a string slice in the middle of a                        multibyte character, your program will exit with an error",
              "key": "C"
            },
            {
              "content": "String Slice mutably borrows the String itself",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ef79a0da-3da6-445e-92b5-1d0e17799db6",
          "type": "SingleChoice",
          "content": "What will happen at the runtime if overflow occurs?",
          "hint": "NoHint",
          "explanation": "The memory stack is full and overflows, so a default panic occurs                 and the program crashes",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Panic and crashes the program",
              "key": "A"
            },
            {
              "content": "Garbage values will be output",
              "key": "B"
            },
            {
              "content": "Those values are ignored and the output is as expected",
              "key": "C"
            },
            {
              "content": "Overflow is handled already by rust, so it doesn’t occur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b152ab5-6524-49e0-b5c0-8bd5153b1ab1",
          "type": "SingleChoice",
          "content": "Character literals are specified using double quotes, as opposed to single quotes which stand for string literals.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "strings",
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "b49785fb-dd24-43b5-9f5a-e7dedc98cc5f",
          "type": "SingleChoice",
          "content": "Strings size is not known at compile time",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "504040ac-6167-4304-8d6e-1e559975bac5",
          "type": "SingleChoice",
          "content": "For the following code\n ```  \n   fn main() {\n     let mut x = 2.0;\n     x: i32= 3.0; \n   }\n ```\n",
          "hint": "type declaration",
          "explanation": "i32 is intialized as a float data type",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The code compiles without errors",
              "key": "A"
            },
            {
              "content": "The code has errors because of immutability",
              "key": "B"
            },
            {
              "content": "The code has errors because of illegal type conversion",
              "key": "C"
            },
            {
              "content": "The code has errors because of no print and return statements",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0ef2f16-b79d-433a-af54-dc218060ef13",
          "type": "SingleChoice",
          "content": "If you want to store boolean values with the provision of adding more             values at runtime, the most suitable way would be to use",
          "hint": "Statically and Dynamic in nature",
          "explanation": "Vector is a Dynamic nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays",
              "key": "A"
            },
            {
              "content": "Tuples",
              "key": "B"
            },
            {
              "content": "Vectors",
              "key": "C"
            },
            {
              "content": "bool type Variables",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c731455f-5296-4b1f-9aee-46a4f77c25c1",
          "type": "SingleChoice",
          "content": "BOOLEAN is a type of data type that basically gives a tautology or                fallacy.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "f8497eb4-2e55-4e70-98c9-b395f254f412",
          "type": "SingleChoice",
          "content": "What are the categories in which keywords are divided in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Weak",
              "key": "A"
            },
            {
              "content": "Strict",
              "key": "B"
            },
            {
              "content": "Reserved",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "836ae5f7-8e1d-41ad-a0b9-e0ce810cbf93",
          "type": "SingleChoice",
          "content": "Which of the following can be used as a variable name in rust?",
          "hint": "NoHint",
          "explanation": "Rest are keywords in rust",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables",
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "crate",
              "key": "A"
            },
            {
              "content": "match",
              "key": "B"
            },
            {
              "content": "await",
              "key": "C"
            },
            {
              "content": "tuple",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "853bbf17-ceb6-4a7c-9a32-c05f048a9ce6",
          "type": "SingleChoice",
          "content": "Identify the wrong set of rust keywords",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "async, await, where, use",
              "key": "A"
            },
            {
              "content": "Move, return, mut, while",
              "key": "B"
            },
            {
              "content": "union, dyn, try, abstract",
              "key": "C"
            },
            {
              "content": "become, box, do, incur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "118287fb-f962-4c6a-b7bb-f774e36f02bf",
          "type": "SingleChoice",
          "content": "Rust variable names can start with",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Letter, underscore",
              "key": "A"
            },
            {
              "content": "Letter, digits",
              "key": "B"
            },
            {
              "content": "Underscore, digits",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6ffbcd01-5b77-44bd-a9e1-56d3adb81a61",
          "type": "SingleChoice",
          "content": "q What is the result of the following calculation in rust \"1.0/0.0\"\n",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A positive number",
              "key": "A"
            },
            {
              "content": "A negative number",
              "key": "B"
            },
            {
              "content": "An unsigned number",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e8c7d69e-3899-43aa-aaec-e45870a32a3f",
          "type": "SingleChoice",
          "content": "In Rust, every value has its data type. The data type tells the compiler what kind of value it is and how to use it.",
          "hint": "noHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "699f89a5-4c2a-4442-afe7-eabc1fb8f5fa",
          "title": "Introduction to Blockchain Technology",
          "shortTitle": "Intro Blockchain",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=u70_rafPs-0",
          "subTopics": [
            "variables"
          ],
          "details": "This video explains about\n* Point 1\n* Point 2\n"
        }
      ],
      "summaries": [
        {
          "title": "Typed language",
          "shortTitle": "Typed language",
          "key": "typed_language",
          "details": "- Dynamically-Typed Languages\n  * Dynamically-typed languages are the languages where the interpreter assigns variables a data type at runtime based on the variable's value at that time.\n  * Dynamic languages are usually interpreted (with some pre-processing for optimisation) so it is fast to make changes and then immediately run the updated program.\n  * Dynamically-Typed languages allows for Fast Development Cycles and Fast Start-up times.\n  * Some Examples of Dynamically Typed Languages are:- JavaScript, Python, Perl, Ruby, etc.\n- Statically-Typed Languages\n  * Statically-typed languages are the languages where variable types are known at compile time i.e. the type checking is done at compile time.\n  * Many runtime errors become compile time errors as the compiler ensures that you are writing 'correct' code. This leads to a much smoother development experience.\n  * The execution of the code will be faster compared to the dynamically-typed languages.\n  * The compiler can use the type system to provide language features that are more expressive and succinct.\n  * Some examples of Statically-Typed Languages are:- C++, Rust, C, Java, etc.\n- Rust is a Statically-Typed Language\n"
        },
        {
          "title": "Value Types",
          "shortTitle": "Value Types",
          "key": "value-types",
          "details": "- Rust has two major Data Value Types, which include \n    1. Scalar Types\n    2. Compound ypes\n- Scalar Types\n  * A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.\n  - Integers\n    * An integer is a number without a fractional component.\n    * An integer can be of the following sizes:- 8-bit, 16-bit, 32-bit, 64-bit, 128-bit, arch.\n    * Integers can be either signed or unsigned. Signed and unsigned refer to whether it’s possible for the number to be negative—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned).\n    * Integers can be declared using keyword let, and explicitly defining the variable size and it's type of signed or unsigned integer.\n    * For example, we can declare a 64-bit signed and 32-bit unsigned integer in the following ways respectively :- \n    ```\n        1. let mut x: i64 = -20;\n        2. let mut x: u32 = 20;\n    ```\n    * The isize and usize types depend on the architecture of your build, which is denoted in the table as “arch”: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit architecture.\n    * The number literals that can be multiple numeric types allow a type suffix, such as `20u32`, to designate the type. Number literals can also use `_` as a visual separator to make the number easier to read, such as `1_000` , which will have the same value as if you had specified `1000`.\n    - Integer Overflow\n      * Let's say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, integer overflow will occur, which can result in one of two behaviors:- \n        1. When you're compiling in `debug` mode, Rust includes checks for integer overflow that cause your program to panic at runtime if this behavior occurs.\n        2. When you're compiling in release mode with the `--release` flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping.\n  - Floating-Point Types\n    * Floating-Point Types are number with the decimal points.\n    * Floating-point types are f32 and f64, which are 32 bits and 64 bits in size, respectively.\n    * All the Floating-Point Types are signed.\n    * The default Floating-Point Type is of 64-bit.\n    * The `f32` type is a single-precision float, and `f64` has double precision.\n    * We can declare a float type variable in the following ways:- \n     ```\n        fn main() {\n              let x = 2.0; // f64\n              let y: f32 = 3.0; // f32\n        }\n      ```\n  - Boolean Type\n    * There are two possible constant values:- True & False.\n    * Booleans are one byte in size.\n    * They are declared using the keyword 'bool'.\n  - Character Type\n    * Character Data Type doesn't use ASCII values like other programming languages but uses Unicode Scalar Value.\n    * It uses 4 bytes i.e. 32 bits of space for each character rather than 1 byte because of Unicode Scalar Values.\n    * We can use many more types of characters in rust, like, Chinese, emojis, etc.\n- Compound Data Types\n  * Compound types can group multiple values into one type. The two primitive compound types in rust are: Tuples and Arrays.\n  - Tuples\n    * A tuple is a general way of grouping together a number of values with a variety of types into one compound type.\n    * Tuples have a fixed length: once declared, they cannot grow or shrink in size.\n    * Tuples are created by a comma seperated List.\n    * Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same.\n    * For Example:- \n      ```\n        fn main() {\n          let tup: (i32, f64, u8) = (500, 6.4, 1);\n        }\n      ```\n    * We can access a tuple element directly by using a period `(.)` followed by the index of the value we want to access\n    * The tuple without any values has a special name knows as \"unit\".\n    * \"unit's\" value and its corresponding type are both written () and represent an empty value or an empty return type. \n    * Expressions implicitly return the unit value if they don’t return any other value. \n  - Arrays\n    * Arrays are a collection of multiple values, stored in a single entity.\n    * Unlike a tuple, every element of an array must have the same data type.\n    * Arrays in Rust have a fixed length, i.e. they are not dynamic in nature by default.\n    * Arrays are useful when you want your data allocated on the stack rather than the memory heap.\n    * For Example:- \n      ```\n        fn main() {\n            let a: [i32; 5] = [1, 2, 3, 4, 5];\n        }\n      ```\n      Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.\n    *  We can access elements of an array using indexing, like this:\n      ```\n        fn main() {\n            let a = [1, 2, 3, 4, 5];\n        \n            let first = a[0]; // outputs 1\n            let second = a[1]; // outputs 2\n        }\n      ```\n"
        },
        {
          "title": "Variables",
          "shortTitle": "Variables",
          "key": "variables",
          "details": "- Variables are used to store the values of a particular data type\n- Variables and Mutability\n  * In Rust, variables are immutable in nature by default.\n  * When a variable is immutable, once a value is bound to a name, you can’t change that value\n  * To make the variables mutable, we use the keyword:- `mut`.\n  * For Example:-\n    ```\n      fn main() {\n          let mut x = 5;\n          println!(\"The value of x is: {x}\");\n          x = 6;\n          println!(\"The value of x is: {x}\");\n      }\n    ```\n- Constants\n  * Constants are values that are bound to a name and are not allowed to change, i.e. they are also immutable.\n  * Usage of keyword `mut` isn't allowed with constants.\n  * Constants are immutable by default, and also they’re always immutable.\n  * We declare constants using the `const` keyword instead of the `let` keyword, and the type of the value must be annotated.\n  * Constants can be declared in any scope, including the global scope, making them useful for values that many parts of code need to know about.\n  * Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.\n  * For Example:-\n    ```\n      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n    ```\n"
        },
        {
          "title": "Keywords",
          "shortTitle": "Keywords",
          "key": "keywords",
          "details": "- Keywords are predefined, reserved words used in programming that have special meanings to the compiler. Rust divides keywords into three categories:\n    1. Strict\n    2. Reserved \n    3. Weak\n- Strict Keywords\n  * These keywords can only be used in their correct contexts. They cannot be used as the names of: Items, Variables and function parameters, etc.\n  * For Example:- ` mut, break, else, continue, return, impl, etc. ` \n- Reserved Variables\n  * These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords.\n  * For Example:- ` abstract, try, do, final, typeof, etc. `\n- Weak Keywords\n  * These keywords have special meaning only in certain contexts.\n  * For example, it is possible to declare a variable or method with the name `union`.\n"
        },
        {
          "title": "Bit Manipulation",
          "shortTitle": "Bit Manipulation",
          "key": "bit-manupilation",
          "details": "- Bit manipulation is the process of applying logical operations on a sequence of bits to achieve a required result.\n- Bit Mnipulation is strictly done by rust compilers for storing data in variables, for two's compliment and many other purposes.\n"
        },
        {
          "title": "Strings",
          "shortTitle": "Strings",
          "key": "strings",
          "details": "- There are two types of strings in Rust: `String` and `&str`.\n- String\n  * Strings are formed by a list of characters, which is really an \"array of characters\".\n  * A String is stored as a vector of bytes `(Vec<u8>)`.\n  * A String is made up of three components: a pointer to some bytes, a length, and a capacity.\n  * The pointer points to an internal buffer String uses to store its data.\n  * The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.\n  * The buffer is always stored on the heap.\n  * It is guaranteed to always be a valid `UTF-8` sequence. \n  * String is heap allocated, growable and not null terminated.\n  * We can create a String from a literal string with `String::from`\n  * We can append a char to a String with the push method, and append a &str with the `push_str` method\n- &str\n  * The str type, also called a 'string slice', is the most primitive string type.\n  * A &str is made up of two components: a pointer to some bytes, and a length.\n  * `&str` is `(&[u8])` that always points to a valid UTF-8 sequence.\n  * It can be used to view into a String, just like `&[T]` is a view into `Vec<T>`.\n"
        },
        {
          "title": "Package Manager",
          "shortTitle": "Package Manager",
          "key": "package-manager",
          "details": "- A package manager or package-management system is a collection of software tools that automates the process of installing, upgrading, configuring, and removing computer programs for a computer in a consistent manner.\n- Cargo is the Rust package manager.\n"
        }
      ]
    },
    {
      "title": "Ownership and Borrowing",
      "key": "owner-borrow",
      "details": "This chapter introduces the high level memory management and safety with ownership and borrowing.\n - Memory Allocation and Memory Types\n    1. Stacks\n    2. Heaps\n    3. Memory alignment\n    4. Std::mem modules\n - How Rust’s Memory Mode is different from others\n - Ownership\n    1. What is Ownership in rust\n    2. What are Scopes\n    3. Move and Copy Semantics\n - Duplicating Types via Traits\n    1. Copy\n    2. Clone\n - Ownership and Memory Safety\n    1. Dangling Pointers\n    2. Double Free\n    3. Memory Leaks\n - Borrowing\n    1. Borrowing rules\n    2. References and multiple references\n    3. Dangling References\n    4. Method types using borrowing\n - Lifetimes\n    1. Parameters\n    2. Lifetime rules\n    3. Multiple lifetimes\n    4. Lifetime in impl blocks\n",
      "order": 4,
      "questions": [
        {
          "uuid": "e1ccd55d-91f0-48ad-9ec5-9aa3fcf3c241",
          "type": "SingleChoice",
          "content": "How many owners can a value on heap have ?",
          "hint": "NoHint",
          "explanation": "Every value in Rust has exactly 1 owner.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "memory-allocation"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "2",
              "key": "A"
            },
            {
              "content": "1",
              "key": "B"
            },
            {
              "content": "variable value",
              "key": "C"
            },
            {
              "content": "value on heap has no owner",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7b6d2b15-bec7-4740-9083-322f44349d74",
          "type": "SingleChoice",
          "content": "Reference can be used to access the variable outside its scope ?",
          "hint": "NoHint",
          "explanation": "Variable can never be accessed outside its scope.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "memory-allocation"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "918fdd9d-9870-4f28-9dde-c542f07882b0",
          "type": "SingleChoice",
          "content": "What is double free error ?",
          "hint": "NoHint",
          "explanation": "Double free error can occur in theory if 2 variable point to same value and try to free it as they go out of scope.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "memory-allocation"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "2 variables try to free same value as they go out of scope",
              "key": "A"
            },
            {
              "content": "Program free memory used by a variable on heap while it is in scope",
              "key": "B"
            },
            {
              "content": "An out of scope variable is assigned a value again",
              "key": "c"
            },
            {
              "content": "Same variable is used in different scopes",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ad736f97-44d9-4ccc-a6fe-b0fb67c0ea17",
          "type": "SingleChoice",
          "content": "How manu immutable references can a variable have ?",
          "hint": "NoHint",
          "explanation": "A variable can have any number of immutable references.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "borrowing"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "2",
              "key": "B"
            },
            {
              "content": "a variable can have any number of immutable references",
              "key": "C"
            },
            {
              "content": "less than 10",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e635a225-452c-459b-ab44-c52afad1a793",
          "type": "SingleChoice",
          "content": "How manu mutable references can a variable have ?",
          "hint": "NoHint",
          "explanation": "A variable can have once 1 mutable reference, this saves it from data race condition.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "borrowing"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "2",
              "key": "B"
            },
            {
              "content": "a variable can have any number of mutable references",
              "key": "C"
            },
            {
              "content": "references can not be mutable",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c8dea1c7-41e0-4b9a-afef-e3dd72a37222",
          "type": "MultipleChoice",
          "content": "Which of the following are true about variable passing in a function ?",
          "hint": "NoHint",
          "explanation": "Variables are moved or copied while passing to a function depending on whether they are on heap or stack respectively.",
          "answerKeys": [
            "B, C"
          ],
          "subTopics": [
            "borrowing"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "variable passed to a function are always cloned",
              "key": "A"
            },
            {
              "content": "variables on stack are copied when passed to function",
              "key": "B"
            },
            {
              "content": "variables on heap are moved when passed to function",
              "key": "C"
            },
            {
              "content": "variable passed to a function are always copied",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a1aab277-a2b0-42e1-9811-19fba895f78f",
          "type": "SingleChoice",
          "content": "How can a value be accessible in a function after it is moved to another function ?",
          "hint": "NoHint",
          "explanation": "When a value is returned from a function it is again moved to calling scope.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "memory-allocation"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "by creating references to the value before passing to the function",
              "key": "A"
            },
            {
              "content": "a value moved to another function can never be used not in parent function",
              "key": "B"
            },
            {
              "content": "By creating a copy of the value before passing it to function",
              "key": "C"
            },
            {
              "content": "by returning value from function and assigning to a new variable",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c8fdd1df-4c7b-459f-b47a-b45a798ea393",
          "type": "MutipleChoice",
          "content": "What is true about borrowing a variable ?",
          "hint": "NoHint",
          "explanation": "Borrowing can be used to create mutable or immutable references to variable without changing their scope.",
          "answerKeys": [
            "C, D"
          ],
          "subTopics": [
            "ownership"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "borrowed variables can not be mutated",
              "key": "A"
            },
            {
              "content": "borrowing can be used to increase scope of the variable",
              "key": "B"
            },
            {
              "content": "borrowing does not changes the ownership of the variable",
              "key": "C"
            },
            {
              "content": "borrowing creates reference to variable whithout changing its scope",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d816e66d-3e8c-4894-8f20-045504865f24",
          "type": "SingleChoice",
          "content": "When is dangling reference created ?",
          "hint": "NoHint",
          "explanation": "Rust does not allow creating dangling references.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "borrowing"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "it is not possible to create dangling references in rust",
              "key": "A"
            },
            {
              "content": "it is created when a references value goes out of scope",
              "key": "B"
            },
            {
              "content": "it is created when a references value if moved",
              "key": "C"
            },
            {
              "content": "it is created when value of a reference is incremented to next memory location",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ccf096f4-a771-4abe-b784-04db290e2b8e",
          "type": "SingleChoice",
          "content": "References in Rust are always valid ?",
          "hint": "NoHint",
          "explanation": "It is not possible to create invalid references in Rust.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "borrowing"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "8a62b57e-decb-4c7c-b93d-2065ba6bd34b",
          "type": "SingleChoice",
          "content": "What is result of compiling code below ?\n```\n  let mut s = String::from(\"hello\");\n\n  {\n      let r1 = &mut s;\n  }\n\n  let r2 = &mut s;\n```\n",
          "hint": "NoHint",
          "explanation": "Mutable references to a variable in different scopes do not create compilation issue.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "borrowing",
            "variable-scope"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Code does not compiles as it is not possible to have 2 mutable references to a variable",
              "key": "A"
            },
            {
              "content": "Code compiles but breaks at runtime",
              "key": "B"
            },
            {
              "content": "Code compiles successfully as 2 mutable references have different scope",
              "key": "C"
            },
            {
              "content": "Code does not compile as it is not possible to have a mutable reference to a string value",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8e6bc92a-b13c-4cd1-9884-69966f5eda50",
          "type": "MultipleChoice",
          "content": "Which of the following is true about variables on stack ?",
          "hint": "NoHint",
          "explanation": "Variables on stack are fixed in size and follow copy symantics.",
          "answerKeys": [
            "C, D"
          ],
          "subTopics": [
            "memory-allocation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Variables on stack can be moved",
              "key": "A"
            },
            {
              "content": "Variables on stack have size determined dynamically at runtime",
              "key": "B"
            },
            {
              "content": "Variables on stack are fixed in size",
              "key": "C"
            },
            {
              "content": "Variables on stack are copied",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "08415e65-cc8d-4123-bdeb-b9b39cb3a4db",
          "title": "Rust - Ownership and Borrowing",
          "shortTitle": "Ownership",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=1cZ15uAvWro",
          "subTopics": [
            "memory-allocation"
          ],
          "details": "Ownership is one of the most important features of Rust, it helps the language ensure memory safety without the need of garbage collection. Another important concept related to ownership is borrowing.\nThis video explains about\n* Scope and Ownership\n* References and Borrowing\n"
        },
        {
          "uuid": "24e52953-b7aa-4858-bfe9-0050f871b160",
          "title": "Rust - Ownership and Borrowing",
          "shortTitle": "Ownership",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=Tw5Xr68GUSk",
          "subTopics": [
            "variable-scope",
            "borrowing"
          ],
          "details": "Ownership and scope in Rust, writing memory safe code using borrowing.\nThis video explains about\n* Ownership and Scope\n* Writing code using borrowing\n* Immutable and mutable references\n* Rules for borrowing\n"
        },
        {
          "uuid": "86bf13d1-0e3a-40fa-b55c-bdf8fe5a51c4",
          "title": "Rust - Ownership and Borrowing",
          "shortTitle": "Ownership",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=k_WmestbBYw",
          "subTopics": [
            "variable-scope",
            "borrowing"
          ],
          "details": "Ownership and scope in Rust, writing memory safe code using borrowing.\nThis video explains about\n* Ownership and Scope\n* Writing code using borrowing\n* Immutable and mutable references\n* Rules for borrowing\n"
        },
        {
          "uuid": "014d249b-4e19-4a7c-8ab0-c6e9f4dfd2a8",
          "title": "Rust - Ownership and Borrowing",
          "shortTitle": "Ownership",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=6eCV-Q-kjX4",
          "subTopics": [
            "variable-scope",
            "borrowing"
          ],
          "details": "Ownership and scope in Rust, writing memory safe code using borrowing.\nThis video explains about\n* Ownership and Scope\n* Writing code using borrowing\n* Immutable and mutable references\n* Rules for borrowing\n"
        }
      ],
      "summaries": [
        {
          "title": "Memory Allocation",
          "shortTitle": "Memory Allocation",
          "key": "memory-allocation",
          "details": "- Rust has a unique approach towards memory allocation. Data variables are either stored on stack or heap.\n- Memory Management Approach\n  * Different languages have different approach towards memory management.\n  * In rust data with known, fixed size is stored on stack, data with an unknown size at compile time or size that can change is stored on heap.\n- Stack\n  * Stacks are last-in first-out and store fixed size variables.\n  * Memory management on stacks is easy.\n  ![Stack](https://github.com/DoDAO-io/dodao-rust-course/blob/2419453a452b44111d5fa63d76663c831ea83901/images/img_stack.jpg?raw=true)\n- Heap\n  * Heap is less organized, when adding a variable on the heap the memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location.\n  * Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses.\n  ![Heap](https://github.com/DoDAO-io/dodao-rust-course/blob/2419453a452b44111d5fa63d76663c831ea83901/images/img_heap.jpg?raw=true)\n"
        },
        {
          "title": "Variable Scope",
          "shortTitle": "Variable Scope",
          "key": "variable-scope",
          "details": "- In Rust a variable is valid only in its scope, as soon as it goes out of scope its memory is freed.\n- Scope:\n  * As the variable goes out of scope it is no longer valid, at this point Rust automatically returns the memory used by the variable.\n  * Rust’s approach to memory management is unique by scoping is simple and robust.\n  * Other languages use different approaches like garbage collection where that regularly looks for no-longer used memory as the program runs, some other languages depend on programmers regularly freeing up the memory. These approaches are less efficient.\n    ```\n      fn main() {\n        {\n          let str = “Hello World”; // str is valid from this point onwards\n        }\n        // str goes out of scope\n      }\n    ```\n"
        },
        {
          "title": "Ownership",
          "shortTitle": "Ownership",
          "key": "ownership",
          "details": "- Each variable in Rust has an Owner.\n- What is Ownership in rust:\n  * Each value in Rust has an owner\n  * Ownership in Rust strictly follows certain rules, if these rules are violated the program will not compile:\n    - each value in Rust has a owner\n    - there can only be one owner at a time\n    - when the owner goes out of scope, value will be dropped\n  * If any of these rules is violated the program will not compile.\n  * None of these rules slow down the execution at runtime.\n- Moving Data:\n  * When a variable on the heap is assigned to another variable the first one is no longer valid. The ownership of the variable is said to be moved.\n    ```\n      let s1 = String::from(“Hello”);\n      let s2 = s1\n\n      println!(“{}, world!”, s1); // this line gives an error.\n    ```\n  * After the line let s2 = s1, rust considers s1 as no longer valid. Thus trying to use s1 after s2 is created will not work.\n  * While dealing with variables on stack values are not moved, they are rather copied.\n  ![Moving Value](https://github.com/DoDAO-io/dodao-rust-course/blob/2419453a452b44111d5fa63d76663c831ea83901/images/img_move.jpg?raw=true)\n- Double Free Error\n  * The reason for invalidating the original reference after moving the value is to prevent double free error.\n  * Consider both s1 and s2 remain valid after the assignment. When they both go out of scope, they will both try to free the same memory. This is a memory safety bug called double free error. Freeing memory twice can lead to memory corruption which can result in security vulnerability.\n- Functions - Passing and Returning Value\n  * Mechanics of passing and returning value from a function is the same as when assigning value.\n  * Value will be moved or copied depending on whether it is on heap or stack.\n    ```\n      fn main() {\n          let s = String::from(“Hello”);\n          takes_ownership(s); // Function takes ownership of s, so it is no longer valid here\n      }\n\n      fn takes_ownership(some_string: String) {\n          println!(some_string);\n      } // some_string goes out of scope after function call\n    ```\n  * To be able to access the value s after function call we need to return it:\n    ```\n      fn main() {\n        let s1 = String::from(“Hello”);\n        let s2 = takes_and_return_ownership(s1); // Function takes ownership of s1\n      }\n\n      fn takes_and_return_ownership(some_string: String) {\n          println!(some_string);\n          some_string;\n      } // some_string moves back to calling function\n    ```\n"
        },
        {
          "title": "Borrowing",
          "shortTitle": "Borrowing",
          "key": "borrowing",
          "details": "- The action of creating a reference to a variable is called borrowing.\n- What is Borrowing:\n  * Moving a variable on the heap is not always convenient.\n  * Consider a situation like passing a variable on heap to a function call, to be able to use a variable after the function call we need to return it from the function. In such situations we can provide a reference to the variable.\n  * Creating a reference to a variable is called borrowing, references can use variables but not own them.\n- Reference\n  * A reference stores the address of the data and we can follow the reference to access data stored at that address, that data is owned by a different variable.\n  * A reference is always guaranteed to point to a valid value for the life of the referenced value.\n  * The value pointed by the reference is not dropped as the reference goes out of scope as it does not have the ownership.\n  * Ampersands are used to represent references.\n    ```\n      fn main() {\n        let s = String::from(“Hello”);\n        calculate_length(&s); // Function takes reference to s\n      }\n\n      fn calculate_length(string_reference: &String) {\n          string_reference.len();\n      }\n    ```\n    ![Reference](https://github.com/DoDAO-io/dodao-rust-course/blob/2419453a452b44111d5fa63d76663c831ea83901/images/img_reference.jpg?raw=true)\n  - Mutable Reference\n    * References can be easily made mutable:\n      ```\n        fn main() {\n          let mut s = String::from(“Hello”);\n          calculate_length(&mut s); // Function takes reference to s\n        }\n\n        fn calculate_length(string_reference: &mut String) {\n            string_reference.push_str(“, world !”);\n        }\n      ```\n    * At any given time there can be one mutable reference or multiple immutable reference to the variable.\n    * This restriction enables rust to prevent data race at compile time.\n  - Dangling Reference\n    * The Rust compiler ensures that dangling references can never exist. Compiler will guarantee that the data will not go out of scope before the reference to the data.\n"
        }
      ]
    },
    {
      "title": "Collections",
      "key": "collections",
      "details": "This chapter talks about various popular pre-written Data Structures that are available in rust.\n - Vec<T>\n - String\n - HashMap<K, V>\n",
      "order": 5,
      "questions": [
        {
          "uuid": "1469d4ec-d02a-4a3c-83a6-cbe9f2fb7fe7",
          "type": "SingleChoice",
          "content": "Where in the mempry are colections stored\n",
          "hint": "NoHint",
          "explanation": "Collections are dynamically sized ans tored on heap.",
          "answerKeys": [
            "C"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_introduction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Stack",
              "key": "A",
              "order": 0
            },
            {
              "content": "Program Area",
              "key": "B",
              "order": 1
            },
            {
              "content": "Heap",
              "key": "C",
              "order": 2
            }
          ]
        },
        {
          "uuid": "671ebf9a-bafe-4b27-a98f-acd14f0b1dc1",
          "type": "SingleChoice",
          "content": "What is the output of the following code snippet:\n \n    ``` \n        let v = Vec![1,2,3,4,5];\n        let third = &v[10];\n\n        println!(“The third element is {}”, third);\n    ```\n",
          "hint": "NoHint",
          "explanation": "Trying to index vector outside it boundries result in panic.",
          "answerKeys": [
            "D"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_vector"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It prints None",
              "key": "A",
              "order": 0
            },
            {
              "content": "It does not print anything",
              "key": "B",
              "order": 1
            },
            {
              "content": "It prints 5",
              "key": "C",
              "order": 2
            },
            {
              "content": "It will resume in panic",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "87b313aa-61ae-4f6f-b251-95028a5eea9d",
          "type": "SingleChoice",
          "content": "What is the output of the following code snippet:\n \n    ``` \n        let v = Vec![1,2,3,4,5];\n        let third = v.get(2);\n\n        println!(“The third element is {}”, third);\n    ```\n",
          "hint": "NoHint",
          "explanation": "Trying to index vector outside it boundries result in panic.",
          "answerKeys": [
            "A"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_vector"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It prints None",
              "key": "A",
              "order": 0
            },
            {
              "content": "It does not print anything",
              "key": "B",
              "order": 1
            },
            {
              "content": "It prints 5",
              "key": "C",
              "order": 2
            },
            {
              "content": "It will resume in panic",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "776ca2cf-bfe1-4fbf-83a2-65432535d6e9",
          "type": "SingleChoice",
          "content": "Strings in Rust support which encoding:\n",
          "hint": "NoHint",
          "explanation": "Strings in Rust support UTF-8 encoding.",
          "answerKeys": [
            "A"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "UTF-8",
              "key": "A",
              "order": 0
            },
            {
              "content": "Unicode",
              "key": "B",
              "order": 1
            },
            {
              "content": "ASCII",
              "key": "C",
              "order": 2
            },
            {
              "content": "UTF-32",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "a57b1b01-84cb-4a59-8eb7-d22440e8b6d5",
          "type": "SingleChoice",
          "content": "What is the output of the following code snippet:\n \n    ``` \n        let s1 = “Hello, “;\n        let s2 = “world!“;\n        let s3 = s1 + &s2;\n\n        println!(s1 is {}”, s1);\n    ```\n",
          "hint": "NoHint",
          "explanation": "When using + macro first argument is moved and not accessible after that.",
          "answerKeys": [
            "A"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Program will not compile",
              "key": "A",
              "order": 0
            },
            {
              "content": "It prints Hello, ",
              "key": "B",
              "order": 1
            },
            {
              "content": "It prints Hello, world!",
              "key": "C",
              "order": 2
            },
            {
              "content": "It prints None",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "08f69431-88dd-4e54-91ea-6e462181a4b3",
          "type": "SingleChoice",
          "content": "How can strings be indexed in Rust ?\n",
          "hint": "NoHint",
          "explanation": "String indexing is not allowed in Rust.",
          "answerKeys": [
            "B"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`str[1]`",
              "key": "A",
              "order": 0
            },
            {
              "content": "String indexing does not works in Rust",
              "key": "B",
              "order": 1
            },
            {
              "content": "`str.1`",
              "key": "C",
              "order": 2
            },
            {
              "content": "`str.get(1)`",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "96c4703a-812b-4428-b211-945ef8bdc46f",
          "type": "SingleChoice",
          "content": "Which hashmap method can be used to add an entry to map only if it does not already exists ?\n",
          "hint": "NoHint",
          "explanation": "`or_insert` will insert an entry into HashMap only if it does not already exist.",
          "answerKeys": [
            "C"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_hashmap"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`insert`",
              "key": "A",
              "order": 0
            },
            {
              "content": "`push`",
              "key": "B",
              "order": 1
            },
            {
              "content": "`or_insert`",
              "key": "C",
              "order": 2
            },
            {
              "content": "`insert_or`",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "d74074f8-3849-4c74-aa6b-3cbddb0ad97d",
          "type": "MultipleChoice",
          "content": "Which of the following are methods available on Vectors ?\n",
          "hint": "NoHint",
          "explanation": "Methods `len` and `push` are available on Vectors.",
          "answerKeys": [
            "A, D"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_vector"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`len`",
              "key": "A",
              "order": 0
            },
            {
              "content": "`length`",
              "key": "B",
              "order": 1
            },
            {
              "content": "`replace`",
              "key": "C",
              "order": 2
            },
            {
              "content": "`push`",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "e5f0e3b1-e56b-4fd3-9211-86b2ad57a078",
          "type": "SingleChoice",
          "content": "Vectors and HashMap needs to be explicitly included in the scope.\n",
          "hint": "NoHint",
          "explanation": "Only HashMap need to be explicitly included in the scope.",
          "answerKeys": [
            "A"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_vector"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A",
              "order": 0
            },
            {
              "content": "False",
              "key": "B",
              "order": 1
            }
          ]
        },
        {
          "uuid": "af1c8fe0-c248-4b59-b0f5-bab0975fc93e",
          "type": "MultipleChoice",
          "content": "Which of the following are methods available on Strings ?\n",
          "hint": "NoHint",
          "explanation": "Methods `contains` and `trim` are available on Strings.",
          "answerKeys": [
            "C, D"
          ],
          "topic": "collections",
          "subTopics": [
            "collection_vector"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`index`",
              "key": "A",
              "order": 0
            },
            {
              "content": "`length`",
              "key": "B",
              "order": 1
            },
            {
              "content": "`contains`",
              "key": "C",
              "order": 2
            },
            {
              "content": "`trim`",
              "key": "D",
              "order": 3
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "037554bd-80e3-40bd-8bb5-60633cffef7d",
          "title": "Rust - Collections",
          "shortTitle": "Collections",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=tTUFl8c_Z0w",
          "subTopics": [
            "collection_vector",
            "collection_strings"
          ],
          "details": "Introduction to popular collection types in Rust\n* Vec<T>\n* HashMap<K, V>\n* HashSet<T>\n* VecDeque<T>\n* LinkedList<T>\n"
        },
        {
          "uuid": "9d8a8dbd-3dd4-44aa-8d79-8e10dddb23fe",
          "title": "Rust - Collections Demo",
          "shortTitle": "Collections Demo",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=yAw3cpqIXtg",
          "subTopics": [
            "collection_vector",
            "collection_hashmap"
          ],
          "details": "Demo of code written using Collection Data Structures in Rust\n"
        }
      ],
      "summaries": [
        {
          "title": "Introduction",
          "shortTitle": "Introduction",
          "key": "collection_introduction",
          "summary": "Collections are useful data structure in Rust that can contain multiple values.",
          "details": "- Collections can contain multiple values\n- Collections are stored on Heap and are dynamically sized, their size is not required to be known at compile time\n- Rust collections can be grouped into 4 major categories:\n  * Sequences - Vec, VecDeque, LinkedList\n  * Maps - HashMap, BTreeMap\n  * sets: HashSet, BTreeSet\n  * Misc: BinaryHeap\n- 3 of most common collections are:\n  * Vector\n  * String\n  * HashMap\n"
        },
        {
          "title": "Vector",
          "shortTitle": "Vector",
          "key": "collection_vector",
          "summary": "Vector allow to store more than 1 value in single data structure.",
          "details": "- Vector has multiple items of same time stored next to each other in memory.\n- Creating a vector\n  * creating an empty vector\n    ```\n    let v: Vec<i32> = Vec::new();\n    ```\n  * creating vector using vec! macro\n    ```\n    let v = vec![1, 2, 3];\n    ```\n- Adding a value of a vector\n  * Value can be added to vector using method `push`\n    ```\n    let mut v = Vec::new();\n\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    ```\n- Reading elements of a vector\n  * There are 2 ways to read elements in vector - indexing, using get method\n  * Indexing\n    ```\n    let v = Vec![1,2,3,4,5];\n    let third = &v[2];\n\n    println!(“The third element is {}”, third);\n\n    ```\n  * Using get method\n    ```\n    let v = Vec![1,2,3,4,5];\n    let third = v.get(2);\n\n    println!(“The third element is {}”, third);\n    ```\n  * If user access a value outside the vector, if using indexing it will panic, if `get` method it will return None.\n  * According to borrow checker rule, if there is a reference created to an element in the vector, vector can not be modified.\n- Iterating over vector\n  * For loop can be used to iterate over vector\n    ```\n    let v = Vec![1,2,3,4,5];\n    for i in &v {\n        println!(“{}”, i);\n    }\n    ```\n  * To mutate a vector while iterating\n    ```\n    let mut v = Vec![1,2,3,4,5];\n    for i in &mut v {\n        *i += 50;\n        println!(“{}”, i);\n    }\n    ```\n- Useful method in vector\n  * len `vec.len()`: gives length of the vector\n  * capacity `vec.capacity()`: gives total capacity of the vector in bytes\n  * contains `vec.contains(v)`: check if a vector contains the element\n  * remove `vec.remove(index)`: remove an element from specified index in the vector\n  * pop `vec.pop()`: remove an element from end of the vector\n  * push `vec.push(v)`: adds an element to the end of the vector\n"
        },
        {
          "title": "Strings",
          "shortTitle": "Strings",
          "key": "collection_strings",
          "summary": "Strings in Rust are a collection of bytes.",
          "details": "- Strings are collection of bytes that support UTF-8 encoded text.\n- Thus different characters of most languages can be represented in Rust.\n- Creating a string:\n  * Empty string can be created as\n    ```\n    let mut s = String::new();\n    ```\n  * Creating a string with initial value\n    ```\n    let s = “initial_value”.to_string();\n    or\n    let s = String::from(“initial_value”);\n    ```\n- Updating a string:\n  * Text can be appended to string using `push_str` and `push` methods.\n    * `push_str` ethod can be used to append a string to another.\n    * Signature of `push_str` is `pub fn push_str(&mut self, string: &str)`\n    * `push_str` does not take ownership of the string passed.\n      ```\n      let mut s = String::from(“Hello, ”);\n      s.push_str(“world”);\n      ```\n    * `push` method can be used to append single character to string:\n      ```\n      let mut s = String::from(“Ca”);\n      s.push(“t”);\n      ```\n  * Strings can be concatenated using + macro\n    ```\n    let s1 = “Hello, “;\n    let s2 = “world!“;\n\n    let s3 = s1 + &s2;\n    ```\n    * + macro uses a method whose signature is `fn add(self, s: &str) -> string`\n    * in above example string s1 is moved and is not accessible after concatenation while reference to string &s2 is appended to it.\n  * For a more complicated string combining format! macro can be used:\n    ```\n    let s1 = “tic”;\n    let s1 = “tac”;\n    let s1 = “toe”;\n\n    let s = format!(“{}-{}-{}”, s1, s2, s3);\n    ```\n- Rust does not allow indexing strings. This limitation comes from the way strings are implemented in rust. Strings are internally array of bytes.\n- Iterating over string:\n  * A string can be tokenized on while space or any character token:\n    ```\n    for s in str.split_whitespace {\n        println!(“{}”, found);\n    }\n\n    for s in str.split(‘,’) {\n        println!(“{}”, found);\n    }\n    ```\n  * It is also possible to iterate over characters or bytes of string:\n    ```\n    for c in “Зд”.chars() {\n        println!(c);\n    }\n    // above will print\n    // 3\n    // д\n    ```\n\n    ```\n    for c in “Зд”.bytes() {\n        println!(c);\n    }\n\n    // Will print:\n    // 208\n    // 151\n    // 208\n    // 180\n    ```\n- Other useful string methods include:\n  * len `str.len()`: gives length of the string\n  * capacity `str.capacity()`: gives total capacity of the string in bytes\n  * contains `str.contains(v)`: find a substring in the parent string\n  * replace `str.replace(\"replace_str1\", \"replace_str2\")`: replace a substring in the parent string\n  * trim `str.trim()`: trim a string\n"
        },
        {
          "title": "HashMap",
          "shortTitle": "HashMap",
          "key": "collection_hashmap",
          "summary": "HashMap stores a mapping of keys to value.",
          "details": "- The type HashMap<K, V> stores a mapping of keys of type K to values of type V\n- Mapping from key K to value V is done using hashing that determines how these values are placed in memory.\n- Keys in hashMap can be of any type but all the kes should be of same type, similarly all the values should also be of same type.\n- Creating a HashMap:\n  * HashMap needs to be explicitly included in the scope.\n  * Also, there is no support of macro for creating HashMap.\n  * HashMap can be created as follows:\n    ```\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::New();\n\n    scores.insert(String::from(“Blue”), 10);\n    scores.insert(String::from(“Yellow”), 20);\n    ```\n- Accessing values in HashMap\n  * values in HashMap can be accessed using `get` function:\n    ```\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::New();\n\n    scores.insert(String::from(“Blue”), 10);\n    scores.insert(String::from(“Yellow”), 20);\n\n    let team_name = String::from(“Blue”);\n    const score = scores.get(team_name);\n    ```\n  * It is also possible to iterate over values of a HashMap:\n    ```\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::New();\n\n    scores.insert(String::from(“Blue”), 10);\n    scores.insert(String::from(“Yellow”), 20);\n\n      for (key, value) in & scores {\n          println!(“{}, {}”, key, value);\n      }\n    ```\n  * Updating a HashMap\n    - A value in HashMap can be overridden by inserting the kay again.\n      ```\n      use std::collections::HashMap;\n\n      let mut scores = HashMap::New();\n\n      scores.insert(String::from(“Blue”), 10);\n      scores.insert(String::from(“Blue”), 20);\n\n      println!(“{:?}”, scores); // this will print {“Blue”: 20}\n      ```\n    - Function `or_insert` can be used to add a key if it is not already present:\n      ```\n      use std::collections::HashMap;\n\n      let mut scores = HashMap::New();\n      scores.insert(String::from(“Blue”), 10);\n\n\n      scores.entry(String::from(“Yello”)).or_insert(20);\n      scores.entry(String::from(“Blue”)).or_insert(50);\n\n      println!(“{:?}”, scores); // this will print {“Yellow”: 20, “Blue”: 10}\n      ```\n"
        }
      ]
    },
    {
      "title": "Pointers and Iterators",
      "key": "point-iter",
      "details": "This chapter explains about pointers and iterators in detail.\n - Reference type pointers\n - Raw Pointers\n - Smart Pointers \n    1. Types\n    2. Drop\n    3. Deref and DerefMUT\n - Uses of Interior Mutability\n - Introduction to Iterators\n - Uses and advantages of Iterators\n",
      "order": 6,
      "questions": [
        {
          "uuid": "ab88a2ab-c80b-49f5-9ea0-b5ed8e4933b1",
          "type": "SingleChoice",
          "content": "What is the output of the following code snippet:\n \n    ``` \n        fn main() {\n          let x = 12;\n          println!(\"The value of x is: {x}\");\n          x = 8;\n          println!(\"The value of x is: {x}\");\n        } \n    ```\n",
          "hint": "NoHint",
          "explanation": "Error would occur, because the variable x isn't set as mutable so it's value can't be changed.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The value of x is: 8",
              "key": "A"
            },
            {
              "content": "Error: the variable x is mutable",
              "key": "B"
            },
            {
              "content": "The value of x is: 12",
              "key": "C"
            },
            {
              "content": "Error: the variable x is immutable",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "23a0e9e5-6c47-4512-98a5-4cd3ab6eff25",
          "type": "SingleChoice",
          "content": "Space taken by a Character data type in rust is",
          "hint": "It doesn't use ASCII values",
          "explanation": "Rust's char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1 byte",
              "key": "A"
            },
            {
              "content": "4 bytes",
              "key": "B"
            },
            {
              "content": "8 bytes",
              "key": "C"
            },
            {
              "content": "16 bytes",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "39385b22-7604-492f-9c2e-aaae409c6b79",
          "type": "SingleChoice",
          "content": "Rust is a Dynamically typed language.",
          "hint": "Does the compiler need to know the data type at compile time?",
          "explanation": "It is statically typed",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "6b844c24-f769-4662-a591-83c0a5f8c6c3",
          "type": "SingleChoice",
          "content": "Select the incorrect declaration statement",
          "hint": "NoHint",
          "explanation": "It is declared as an unsigned integer, but the value is negative",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let mut x: u32 = 20;",
              "key": "A"
            },
            {
              "content": "let mut x: i32 = -20;",
              "key": "B"
            },
            {
              "content": "let mut x: u32 = -20;",
              "key": "C"
            },
            {
              "content": "let mut x = 20;",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6f2cb4ae-db4d-4c04-bfd4-37669695dab0",
          "type": "SingleChoice",
          "content": "Suppose you declared a variable as u8 and then assigned it a value of \"257\". What would be the output if it’s compiled with a \"`“--release” flag?`\"",
          "hint": "NoHint",
          "explanation": "After 255 the digits start rolling back to 0, 1 and so on",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "257",
              "key": "A"
            },
            {
              "content": "Error: Integer Overflow",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0708f185-46b5-45ee-ac47-3e7e1ca611b3",
          "type": "SingleChoice",
          "content": "Are Tuples in rust dynamic in nature?\n\"Eg:-\" \n``` \n  let tup: (i32, f64, bool) = (500, 6.4, true); \n```\n",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Yes",
              "key": "A"
            },
            {
              "content": "No",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d11a531f-f32f-4764-a60a-2cc5af348245",
          "type": "SingleChoice",
          "content": "Select the correct statements for the two String     types(“String” and “&str”).\n \"a. “Strings” are immutable in nature and cannot be modified. \"\n \"b. “&str” is a primitive data type, whereas “String” is implemented in the standard library.\"\n \"c. To read a file into the strings, we use the read_to_string() method.\"\n",
          "hint": "NoHint",
          "explanation": "Strings are mutable in nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Only a",
              "key": "A"
            },
            {
              "content": "Both a & b",
              "key": "B"
            },
            {
              "content": "Both b & c",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9511276a-dd19-47c4-b086-0d1de8cafedb",
          "type": "SingleChoice",
          "content": "Which among the following is not an acceptable keyword in rust?",
          "hint": "NoHint",
          "explanation": "var is not a keyword in rust",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "let",
              "key": "A"
            },
            {
              "content": "var",
              "key": "B"
            },
            {
              "content": "impl",
              "key": "C"
            },
            {
              "content": "mut",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1ed70de2-99c6-43dd-8793-40ad702d6bff",
          "type": "SingleChoice",
          "content": "Which of the following brackets are used as placeholders in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "{}",
              "key": "A"
            },
            {
              "content": "[ ]",
              "key": "B"
            },
            {
              "content": "( )",
              "key": "C"
            },
            {
              "content": "< >",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7f129510-4d19-4a62-bae1-34109714fa0e",
          "type": "SingleChoice",
          "content": "Constants in rust can be defined in which scope?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Global",
              "key": "A"
            },
            {
              "content": "Method",
              "key": "B"
            },
            {
              "content": "Local",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b29fa10c-2efa-478c-8207-2e2a80af8700",
          "type": "SingleChoice",
          "content": "Which of the following are the scalar data types present in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "integers, floating-point numbers, booleans, characters",
              "key": "A"
            },
            {
              "content": "integers, signed numbers, unsigned numbers, booleans, characters",
              "key": "B"
            },
            {
              "content": "integers, strings, signed numbers, unsigned numbers, booleans",
              "key": "C"
            },
            {
              "content": "integers, floating-point numbers, strings, booleans",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "775949c1-23b7-42bc-b184-bc755c8d2657",
          "type": "SingleChoice",
          "content": "The compound data types supported by rust are-",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays, Lists, Red-Black Trees",
              "key": "A"
            },
            {
              "content": "Arrays, Lists, Vectors",
              "key": "B"
            },
            {
              "content": "Arrays, Tuples",
              "key": "C"
            },
            {
              "content": "Arrays, Maps",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7fd341f0-4921-4e6e-aa0c-c3897f91d3b2",
          "type": "SingleChoice",
          "content": "Which are valid array declarations in rust? \n``` \n       let mut arr : {i64, 3} = [2,3,5];\n       let mut arr : {3,3};\n       let mut arr = [2,3,5];\n ```\n",
          "hint": "Look for the wrong declaration format, you may or may not find it",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both a & b",
              "key": "A"
            },
            {
              "content": "Both b & c",
              "key": "B"
            },
            {
              "content": "Only a",
              "key": "C"
            },
            {
              "content": "All a, b, & c",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "75d926cd-6f05-4185-916c-fc6c2b90eecd",
          "type": "SingleChoice",
          "content": "Which of the following has low memory usage, const or static?",
          "hint": "How many of these can we update?",
          "explanation": "Constant doesn't uses any extra heap memory to update",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "const",
              "key": "A"
            },
            {
              "content": "static",
              "key": "B"
            },
            {
              "content": "depends upon the data type",
              "key": "C"
            },
            {
              "content": "both have the same memory usage",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a7495120-1470-41d4-aeb2-6d9d7ebd876c",
          "type": "SingleChoice",
          "content": "To use dynamic-sized variables, which of the following should be used?",
          "hint": "No hint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Arrays & Tuples",
              "key": "A"
            },
            {
              "content": "List all the data types",
              "key": "B"
            },
            {
              "content": "Sized",
              "key": "C"
            },
            {
              "content": "Dynamic-Sized variables not supported in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4c564a7d-28d3-4fca-a06d-f3f3fc419d13",
          "type": "SingleChoice",
          "content": "What is the importance of the “type” keyword in rust?",
          "hint": "Used for another types.",
          "explanation": "Sets an alias of another type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "used for dynamic-sized data type",
              "key": "A"
            },
            {
              "content": "used to create a template",
              "key": "B"
            },
            {
              "content": "used for user-defined data type",
              "key": "C"
            },
            {
              "content": "used to set an alias of another type",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d677a228-7f5d-4b5f-8bee-9f40052efafb",
          "type": "SingleChoice",
          "content": "What is the importance of Cargo in rust?",
          "hint": "What is npm used for?",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "package-manager"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Collection of rust libraries",
              "key": "A"
            },
            {
              "content": "Modules Package manager",
              "key": "B"
            },
            {
              "content": "Build system and Package manager",
              "key": "C"
            },
            {
              "content": "Used to create and build UI projects in rust",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2715ab2c-35b3-4e6a-9697-f244c6e23676",
          "type": "SingleChoice",
          "content": "How to print the data type of a variable in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": " `std::any::type_name` ",
              "key": "A"
            },
            {
              "content": " `variable.type_name()` ",
              "key": "B"
            },
            {
              "content": " `std::intrisic::type_name` ",
              "key": "C"
            },
            {
              "content": " `std::variable::type_name` ",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e326751d-bb65-44e4-a6ce-fa62faa96f94",
          "type": "SingleChoice",
          "content": "Which type cast preserves the mathematical value in all cases?",
          "hint": "NoHint",
          "explanation": "Because they can handle both signed and unsigned values, and are typecasted in one data type only.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "bit-manupilation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "i32 as i64",
              "key": "A"
            },
            {
              "content": "i64 as i32",
              "key": "B"
            },
            {
              "content": "usize as u64",
              "key": "C"
            },
            {
              "content": "f64 as f32",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ffac79fe-2367-42d1-82eb-b6e6127aead5",
          "type": "SingleChoice",
          "content": "Which of the following cannot be destructed further into smaller segments?",
          "hint": "Think of the structures they're built upon ",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Tuples",
              "key": "A"
            },
            {
              "content": "Traits",
              "key": "B"
            },
            {
              "content": "Arrays",
              "key": "C"
            },
            {
              "content": "Structs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b0a3444-3b86-4e09-8021-f4b66cb2ce09",
          "type": "SingleChoice",
          "content": "Which comment syntax is not legal?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "<//>",
              "key": "A"
            },
            {
              "content": "/* */",
              "key": "B"
            },
            {
              "content": "//!",
              "key": "C"
            },
            {
              "content": "//",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f9d0f0d-4670-44d7-b69f-d398ecfb3236",
          "type": "SingleChoice",
          "content": "Values of the array can be deleted.",
          "hint": "NoHint",
          "explanation": "Values can be updated, but can't be deleted",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "d2af3b88-9912-4729-9673-4101b7ec4765",
          "type": "SingleChoice",
          "content": "How do you initialize every element of an array of size 5 with 0?",
          "hint": "Look at the declarations, don't get confused by the order while declaring",
          "explanation": "The first argument is the integer you want to initialize an element with, and the second argument tells the end posistion till where you want to pre-initialize.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "`let mut arr : {i32;5} = {5;0};`",
              "key": "A"
            },
            {
              "content": "`let mut arr : {i32;5} = {0;5};`",
              "key": "B"
            },
            {
              "content": "`let mut arr : {5;i32} = {5;0};`",
              "key": "C"
            },
            {
              "content": "`let mut arr : {5;i32} = {0;5};`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "93c0673c-a86b-4bbb-82b0-3bb77bddab67",
          "type": "SingleChoice",
          "content": "Tuples in rust are",
          "hint": "NoHint",
          "explanation": "They can handle and store different data types",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "finite heterogeneous compound data types",
              "key": "A"
            },
            {
              "content": "finite homogeneous compound data types",
              "key": "B"
            },
            {
              "content": "infinite heterogeneous compound data types",
              "key": "C"
            },
            {
              "content": "infinite homogeneous compound data types",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8c7f2429-0db2-4288-bd4a-ef694b39206c",
          "type": "SingleChoice",
          "content": "What would be the output of the following code snippet?\n  ```\n    Fn main( ) {\t\n      let mut dodao_io = (\"\"Do\"\", 69, \"\"DAO\"\", 420);\n      println!(\"\"{} \"\", dodao_io );\n      println!(\"\"at 0 index = {} \"\", gfg.0 );\n    } \n  ```\n",
          "hint": "No Hint",
          "explanation": "The first print statement should've had {;?}",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & Do",
              "key": "A"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) only",
              "key": "B"
            },
            {
              "content": "Compilation Error",
              "key": "C"
            },
            {
              "content": "(\"Do\", 69, \"DAO\", 420) & “Do”",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2f6ce66c-3d34-4fa0-b6f6-188b7aa052b9",
          "type": "SingleChoice",
          "content": "What is the process of temporarily making a variable mutable known as?",
          "hint": "NoHint",
          "explanation": "No explantion",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Pseudo-mutability",
              "key": "A"
            },
            {
              "content": "Foreshadowing",
              "key": "B"
            },
            {
              "content": "Shadowing",
              "key": "C"
            },
            {
              "content": "Overshadowing",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d8a49f56-5da8-4b71-b18c-e745d5913dee",
          "type": "SingleChoice",
          "content": "Which of the following is an example of suffix annotation?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "let a_int: i64 = 20;",
              "key": "A"
            },
            {
              "content": "let a_int = i6420;",
              "key": "B"
            },
            {
              "content": "let a_int = 20i64;",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "419058bf-87e9-4c18-9b8e-3f96c3c820b3",
          "type": "SingleChoice",
          "content": "A. println!(\"1 + 2 = {}\", 1u32 + 2);\nB. println!(\"1 - 2 = {}\", 1u32 + 2);\n",
          "hint": "Solution being Positive or Negative might make a difference",
          "explanation": "Here, when initialized, 1 is set as unsigned 32 integer u32. In statement A, it works because  1+2=3, and it's positive. But, 1-2=(-1) and as they were unsigned integers, so they cannot hold a negative value, so this statement doesn't compile\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Only A compiles",
              "key": "A"
            },
            {
              "content": "Only B compiles",
              "key": "B"
            },
            {
              "content": "Both A & B compile",
              "key": "C"
            },
            {
              "content": "None of them complies",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d97fc146-6c06-4a5c-a738-93a00cf7214e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n\"``` println!(\"{}\", 1_00u32 + 2_0); ```\"\n",
          "hint": "NoHint",
          "explanation": "1_000u32 is similar as 100 of u32 type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "Compilation Error",
              "key": "A"
            },
            {
              "content": "Runtime Error",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "120",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2448d741-4c38-46f3-b681-c3ffb44e54ac",
          "type": "SingleChoice",
          "content": "String in standard library has more functionalities coded into it than string slice?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Moderate",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "923d11ba-5c1c-4d48-8101-87ee08e0fa0e",
          "type": "SingleChoice",
          "content": "What is the output of the following code\n  ```\n  fn main() {\n    let first_string = \"This is some string \".to_string();\n    let second_string = \"Let's add some Data\";\n\n    let final_string = first_string + &second_string;\n\n    println!(\"First string is: {}\", first_string);   \n    println!(\"Second string is: {}\", second_string);\n\n    println!(\"Finally we have: {}\", final_string);\n  }\n  ```\n",
          "hint": "NoHint",
          "explanation": "Syntatical Error in the code snippet",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Only 1st print statement shows an output",
              "key": "A"
            },
            {
              "content": "Only 1st and 2nd print statement shows an output",
              "key": "B"
            },
            {
              "content": "All the 3 string statements show an output",
              "key": "C"
            },
            {
              "content": "Error occurs",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ec5e9c9b-cafa-484e-8feb-51db5a0b7a33",
          "type": "SingleChoice",
          "content": "Which of the following operator is used by string slices to reference?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`&`",
              "key": "A"
            },
            {
              "content": "`%`",
              "key": "B"
            },
            {
              "content": "`#`",
              "key": "C"
            },
            {
              "content": "`*`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d0b24301-eda6-49d7-bf45-88777b13e15f",
          "type": "SingleChoice",
          "content": "Select the incorrect statement from the following",
          "hint": "Nohint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Once you get a string slice from a string, then you cannot really                 modify that String anymore",
              "key": "A"
            },
            {
              "content": "Using slices to work with Strings allows us to add an extra                       security measure.",
              "key": "B"
            },
            {
              "content": "If you attempt to create a string slice in the middle of a                        multibyte character, your program will exit with an error",
              "key": "C"
            },
            {
              "content": "String Slice mutably borrows the String itself",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ef79a0da-3da6-445e-92b5-1d0e17799db6",
          "type": "SingleChoice",
          "content": "What will happen at the runtime if overflow occurs?",
          "hint": "NoHint",
          "explanation": "The memory stack is full and overflows, so a default panic occurs                 and the program crashes",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Panic and crashes the program",
              "key": "A"
            },
            {
              "content": "Garbage values will be output",
              "key": "B"
            },
            {
              "content": "Those values are ignored and the output is as expected",
              "key": "C"
            },
            {
              "content": "Overflow is handled already by rust, so it doesn’t occur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1b152ab5-6524-49e0-b5c0-8bd5153b1ab1",
          "type": "SingleChoice",
          "content": "Character literals are specified using double quotes, as opposed to single quotes which stand for string literals.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "strings",
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "b49785fb-dd24-43b5-9f5a-e7dedc98cc5f",
          "type": "SingleChoice",
          "content": "Strings size is not known at compile time",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "504040ac-6167-4304-8d6e-1e559975bac5",
          "type": "SingleChoice",
          "content": "For the following code\n ```  \n   fn main() {\n     let mut x = 2.0;\n     x: i32= 3.0; \n   }\n ```\n",
          "hint": "type declaration",
          "explanation": "i32 is intialized as a float data type",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types",
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The code compiles without errors",
              "key": "A"
            },
            {
              "content": "The code has errors because of immutability",
              "key": "B"
            },
            {
              "content": "The code has errors because of illegal type conversion",
              "key": "C"
            },
            {
              "content": "The code has errors because of no print and return statements",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0ef2f16-b79d-433a-af54-dc218060ef13",
          "type": "SingleChoice",
          "content": "If you want to store boolean values with the provision of adding more             values at runtime, the most suitable way would be to use",
          "hint": "Statically and Dynamic in nature",
          "explanation": "Vector is a Dynamic nature",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Arrays",
              "key": "A"
            },
            {
              "content": "Tuples",
              "key": "B"
            },
            {
              "content": "Vectors",
              "key": "C"
            },
            {
              "content": "bool type Variables",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c731455f-5296-4b1f-9aee-46a4f77c25c1",
          "type": "SingleChoice",
          "content": "BOOLEAN is a type of data type that basically gives a tautology or                fallacy.",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "f8497eb4-2e55-4e70-98c9-b395f254f412",
          "type": "SingleChoice",
          "content": "What are the categories in which keywords are divided in rust?",
          "hint": "NoHint",
          "explanation": "No explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Weak",
              "key": "A"
            },
            {
              "content": "Strict",
              "key": "B"
            },
            {
              "content": "Reserved",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "836ae5f7-8e1d-41ad-a0b9-e0ce810cbf93",
          "type": "SingleChoice",
          "content": "Which of the following can be used as a variable name in rust?",
          "hint": "NoHint",
          "explanation": "Rest are keywords in rust",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "variables",
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "crate",
              "key": "A"
            },
            {
              "content": "match",
              "key": "B"
            },
            {
              "content": "await",
              "key": "C"
            },
            {
              "content": "tuple",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "853bbf17-ceb6-4a7c-9a32-c05f048a9ce6",
          "type": "SingleChoice",
          "content": "Identify the wrong set of rust keywords",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "keywords"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "async, await, where, use",
              "key": "A"
            },
            {
              "content": "Move, return, mut, while",
              "key": "B"
            },
            {
              "content": "union, dyn, try, abstract",
              "key": "C"
            },
            {
              "content": "become, box, do, incur",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "118287fb-f962-4c6a-b7bb-f774e36f02bf",
          "type": "SingleChoice",
          "content": "Rust variable names can start with",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Letter, underscore",
              "key": "A"
            },
            {
              "content": "Letter, digits",
              "key": "B"
            },
            {
              "content": "Underscore, digits",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6ffbcd01-5b77-44bd-a9e1-56d3adb81a61",
          "type": "SingleChoice",
          "content": "q What is the result of the following calculation in rust \"1.0/0.0\"\n",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A positive number",
              "key": "A"
            },
            {
              "content": "A negative number",
              "key": "B"
            },
            {
              "content": "An unsigned number",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e8c7d69e-3899-43aa-aaec-e45870a32a3f",
          "type": "SingleChoice",
          "content": "In Rust, every value has its data type. The data type tells the compiler what kind of value it is and how to use it.",
          "hint": "noHint",
          "explanation": "No explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "typed_language"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "699f89a5-4c2a-4442-afe7-eabc1fb8f5fa",
          "title": "Introduction to Blockchain Technology",
          "shortTitle": "Intro Blockchain",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=u70_rafPs-0",
          "subTopics": [
            "variables"
          ],
          "details": "This video explains about\n* Point 1\n* Point 2\n"
        }
      ],
      "summaries": [
        {
          "title": "Typed language",
          "shortTitle": "Typed language",
          "key": "typed_language",
          "details": "- Dynamically-Typed Languages\n  * Dynamically-typed languages are the languages where the interpreter assigns variables a data type at runtime based on the variable's value at that time.\n  * Dynamic languages are usually interpreted (with some pre-processing for optimisation) so it is fast to make changes and then immediately run the updated program.\n  * Dynamically-Typed languages allows for Fast Development Cycles and Fast Start-up times.\n  * Some Examples of Dynamically Typed Languages are:- JavaScript, Python, Perl, Ruby, etc.\n- Statically-Typed Languages\n  * Statically-typed languages are the languages where variable types are known at compile time i.e. the type checking is done at compile time.\n  * Many runtime errors become compile time errors as the compiler ensures that you are writing 'correct' code. This leads to a much smoother development experience.\n  * The execution of the code will be faster compared to the dynamically-typed languages.\n  * The compiler can use the type system to provide language features that are more expressive and succinct.\n  * Some examples of Statically-Typed Languages are:- C++, Rust, C, Java, etc.\n- Rust is a Statically-Typed Language\n"
        },
        {
          "title": "Value Types",
          "shortTitle": "Value Types",
          "key": "value-types",
          "details": "- Rust has two major Data Value Types, which include \n    1. Scalar Types\n    2. Compound ypes\n- Scalar Types\n  * A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.\n  - Integers\n    * An integer is a number without a fractional component.\n    * An integer can be of the following sizes:- 8-bit, 16-bit, 32-bit, 64-bit, 128-bit, arch.\n    * Integers can be either signed or unsigned. Signed and unsigned refer to whether it’s possible for the number to be negative—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned).\n    * Integers can be declared using keyword let, and explicitly defining the variable size and it's type of signed or unsigned integer.\n    * For example, we can declare a 64-bit signed and 32-bit unsigned integer in the following ways respectively :- \n    ```\n        1. let mut x: i64 = -20;\n        2. let mut x: u32 = 20;\n    ```\n    * The isize and usize types depend on the architecture of your build, which is denoted in the table as “arch”: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit architecture.\n    * The number literals that can be multiple numeric types allow a type suffix, such as `20u32`, to designate the type. Number literals can also use `_` as a visual separator to make the number easier to read, such as `1_000` , which will have the same value as if you had specified `1000`.\n    - Integer Overflow\n      * Let's say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, integer overflow will occur, which can result in one of two behaviors:- \n        1. When you're compiling in `debug` mode, Rust includes checks for integer overflow that cause your program to panic at runtime if this behavior occurs.\n        2. When you're compiling in release mode with the `--release` flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping.\n  - Floating-Point Types\n    * Floating-Point Types are number with the decimal points.\n    * Floating-point types are f32 and f64, which are 32 bits and 64 bits in size, respectively.\n    * All the Floating-Point Types are signed.\n    * The default Floating-Point Type is of 64-bit.\n    * The `f32` type is a single-precision float, and `f64` has double precision.\n    * We can declare a float type variable in the following ways:- \n     ```\n        fn main() {\n              let x = 2.0; // f64\n              let y: f32 = 3.0; // f32\n        }\n      ```\n  - Boolean Type\n    * There are two possible constant values:- True & False.\n    * Booleans are one byte in size.\n    * They are declared using the keyword 'bool'.\n  - Character Type\n    * Character Data Type doesn't use ASCII values like other programming languages but uses Unicode Scalar Value.\n    * It uses 4 bytes i.e. 32 bits of space for each character rather than 1 byte because of Unicode Scalar Values.\n    * We can use many more types of characters in rust, like, Chinese, emojis, etc.\n- Compound Data Types\n  * Compound types can group multiple values into one type. The two primitive compound types in rust are: Tuples and Arrays.\n  - Tuples\n    * A tuple is a general way of grouping together a number of values with a variety of types into one compound type.\n    * Tuples have a fixed length: once declared, they cannot grow or shrink in size.\n    * Tuples are created by a comma seperated List.\n    * Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same.\n    * For Example:- \n      ```\n        fn main() {\n          let tup: (i32, f64, u8) = (500, 6.4, 1);\n        }\n      ```\n    * We can access a tuple element directly by using a period `(.)` followed by the index of the value we want to access\n    * The tuple without any values has a special name knows as \"unit\".\n    * \"unit's\" value and its corresponding type are both written () and represent an empty value or an empty return type. \n    * Expressions implicitly return the unit value if they don’t return any other value. \n  - Arrays\n    * Arrays are a collection of multiple values, stored in a single entity.\n    * Unlike a tuple, every element of an array must have the same data type.\n    * Arrays in Rust have a fixed length, i.e. they are not dynamic in nature by default.\n    * Arrays are useful when you want your data allocated on the stack rather than the memory heap.\n    * For Example:- \n      ```\n        fn main() {\n            let a: [i32; 5] = [1, 2, 3, 4, 5];\n        }\n      ```\n      Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.\n    *  We can access elements of an array using indexing, like this:\n      ```\n        fn main() {\n            let a = [1, 2, 3, 4, 5];\n        \n            let first = a[0]; // outputs 1\n            let second = a[1]; // outputs 2\n        }\n      ```\n"
        },
        {
          "title": "Variables",
          "shortTitle": "Variables",
          "key": "variables",
          "details": "- Variables are used to store the values of a particular data type\n- Variables and Mutability\n  * In Rust, variables are immutable in nature by default.\n  * When a variable is immutable, once a value is bound to a name, you can’t change that value\n  * To make the variables mutable, we use the keyword:- `mut`.\n  * For Example:-\n    ```\n      fn main() {\n          let mut x = 5;\n          println!(\"The value of x is: {x}\");\n          x = 6;\n          println!(\"The value of x is: {x}\");\n      }\n    ```\n- Constants\n  * Constants are values that are bound to a name and are not allowed to change, i.e. they are also immutable.\n  * Usage of keyword `mut` isn't allowed with constants.\n  * Constants are immutable by default, and also they’re always immutable.\n  * We declare constants using the `const` keyword instead of the `let` keyword, and the type of the value must be annotated.\n  * Constants can be declared in any scope, including the global scope, making them useful for values that many parts of code need to know about.\n  * Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.\n  * For Example:-\n    ```\n      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n    ```\n"
        },
        {
          "title": "Keywords",
          "shortTitle": "Keywords",
          "key": "keywords",
          "details": "- Keywords are predefined, reserved words used in programming that have special meanings to the compiler. Rust divides keywords into three categories:\n    1. Strict\n    2. Reserved \n    3. Weak\n- Strict Keywords\n  * These keywords can only be used in their correct contexts. They cannot be used as the names of: Items, Variables and function parameters, etc.\n  * For Example:- ` mut, break, else, continue, return, impl, etc. ` \n- Reserved Variables\n  * These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords.\n  * For Example:- ` abstract, try, do, final, typeof, etc. `\n- Weak Keywords\n  * These keywords have special meaning only in certain contexts.\n  * For example, it is possible to declare a variable or method with the name `union`.\n"
        },
        {
          "title": "Bit Manipulation",
          "shortTitle": "Bit Manipulation",
          "key": "bit-manupilation",
          "details": "- Bit manipulation is the process of applying logical operations on a sequence of bits to achieve a required result.\n- Bit Mnipulation is strictly done by rust compilers for storing data in variables, for two's compliment and many other purposes.\n"
        },
        {
          "title": "Strings",
          "shortTitle": "Strings",
          "key": "strings",
          "details": "- There are two types of strings in Rust: `String` and `&str`.\n- String\n  * Strings are formed by a list of characters, which is really an \"array of characters\".\n  * A String is stored as a vector of bytes `(Vec<u8>)`.\n  * A String is made up of three components: a pointer to some bytes, a length, and a capacity.\n  * The pointer points to an internal buffer String uses to store its data.\n  * The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.\n  * The buffer is always stored on the heap.\n  * It is guaranteed to always be a valid `UTF-8` sequence. \n  * String is heap allocated, growable and not null terminated.\n  * We can create a String from a literal string with `String::from`\n  * We can append a char to a String with the push method, and append a &str with the `push_str` method\n- &str\n  * The str type, also called a 'string slice', is the most primitive string type.\n  * A &str is made up of two components: a pointer to some bytes, and a length.\n  * `&str` is `(&[u8])` that always points to a valid UTF-8 sequence.\n  * It can be used to view into a String, just like `&[T]` is a view into `Vec<T>`.\n"
        },
        {
          "title": "Package Manager",
          "shortTitle": "Package Manager",
          "key": "package-manager",
          "details": "- A package manager or package-management system is a collection of software tools that automates the process of installing, upgrading, configuring, and removing computer programs for a computer in a consistent manner.\n- Cargo is the Rust package manager.\n"
        }
      ]
    }
  ]
}